<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title>Jeu 3D avec Three.js et Cannon.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #instructions {
            position: absolute;
            top: 50%;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            user-select: none;
            cursor: pointer;
            z-index: 1000;
        }

        /* Style du crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            margin-left: -5px;
            /* Pour centrer horizontalement */
            margin-top: -5px;
            /* Pour centrer verticalement */
            background-color: white;
            border: 2px solid black;
            border-radius: 50%;
            pointer-events: none;
            /* Permet de cliquer à travers le crosshair */
            z-index: 1000;
        }
    </style>
</head>

<body>
    <div id="instructions">Cliquez pour démarrer</div>
    <div id="crosshair"></div> <!-- Ajout du crosshair -->
    <div id="unhealthyCount"
        style="position: absolute; top: 10px; left: 10px; color: white; font-family: Arial, sans-serif; z-index: 1000;">
        Unhealthy Count: 0</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // Pour pas oublier, il faut que je crée un générateur de plateau et. Et ensuite ? Ensuite Une classe générateur de plateau on. Ensuite, il faut que je fasse en sorte que les choses qui peuvent être upgradeable sont la distance pour attraper un objet et aussi. Il faut savoir que en fait, les plateaux auront un indice de mauvaise bouffe et plus on avance Plus les plateaux auront condense à être dans la mauvaise bouffe et avoir un indice élevé de mauvaise bouffe. Et du coup, le joueur devra essayer de de vu qu'il pourra pas attraper tous les plateaux, il devra attraper les plateaux qu'ils ont le plus gros indice de mauvaise bouffe. Ensuite  La vitesse de déplacement sera aussi un élément qui sera upgradable
        // Définir les groupes de collision
        const COLLISION_GROUP_PLAYER = 1 << 0; // 1
        const COLLISION_GROUP_OBJECT = 1 << 1; // 2

        // Gestionnaire des événements
        class EventEmitter {
            constructor() {
                this.events = {};
            }

            on(event, listener) {
                if (!this.events[event]) {
                    this.events[event] = [];
                }
                this.events[event].push(listener);
            }

            emit(event, data) {
                if (this.events[event]) {
                    this.events[event].forEach(listener => listener(data));
                }
            }
        }

        // Gestionnaire de la scène Three.js
        class SceneManager {
            constructor() {
                this.scene = new THREE.Scene();
                // Ajout d'une lumière directionnelle pour mieux voir les objets
                //const light = new THREE.DirectionalLight(0xffffff, 1);
                //light.position.set(5, 10, 7.5);
                //this.scene.add(light);

                // Ajout d'une lumière ambiante
                const ambientLight = new THREE.AmbientLight(0xe0e0e0); // lumière douce
                this.scene.add(ambientLight);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement);
            }

            render(camera) {
                this.renderer.render(this.scene, camera);
            }
        }

        // Gestionnaire de la physique Cannon.js
        class PhysicsManager {
            constructor() {
                this.world = new CANNON.World();
                this.world.gravity.set(0, -9.82, 0);
                this.fixedTimeStep = 1 / 60;
                this.maxSubSteps = 3;
            }

            step() {
                this.world.step(this.fixedTimeStep, undefined, this.maxSubSteps);
            }
        }

        // Gestionnaire des entrées utilisateur
        class InputManager {
            constructor() {
                this.keys = {};
                this.listeners = {};

                this.initControls();
            }

            initControls() {
                document.addEventListener('keydown', (e) => this.onKeyChange(e, true));
                document.addEventListener('keyup', (e) => this.onKeyChange(e, false));
            }

            onKeyChange(event, isPressed) {
                const key = event.key.toLowerCase();
                this.keys[key] = isPressed;

                if (this.listeners[key]) {
                    this.listeners[key].forEach(callback => callback(isPressed));
                }
            }

            bindKey(key, callback) {
                key = key.toLowerCase();
                if (!this.listeners[key]) {
                    this.listeners[key] = [];
                }
                this.listeners[key].push(callback);
            }

            isKeyPressed(key) {
                return !!this.keys[key.toLowerCase()];
            }
        }

        // Classe représentant un objet du jeu
        class GameObject {
            constructor(options) {
                this.scene = options.scene;
                this.world = options.world;
                this.game = options.game;

                // Fusion des options avec les valeurs par défaut
                const defaultTransform = {
                    position: { x: 0, y: 0, z: 0 },
                    rotation: { x: 0, y: 0, z: 0 },
                    size: { x: 1, y: 1, z: 1 }
                };
                const defaultAppearance = {
                    color: 0xffffff,
                    opacity: 1,
                    texture: null, // Chaque GameObject n'a qu'une seule texture
                    repeating: false, // Indique si la texture est en répétition
                    repeatDimensions: { x: 1, y: 1 }, // Dimensions de répétition
                    shapeType: 'box'
                };
                const defaultModel = { path: null };
                const defaultIsDynamic = false;

                this.transform = Object.assign({}, defaultTransform, options.transform);
                this.transform.position = Object.assign({}, defaultTransform.position, options.transform?.position);
                this.transform.rotation = Object.assign({}, defaultTransform.rotation, options.transform?.rotation);
                this.transform.size = Object.assign({}, defaultTransform.size, options.transform?.size);

                this.appearance = Object.assign({}, defaultAppearance, options.appearance);
                this.model = Object.assign({}, defaultModel, options.model);
                this.isDynamic = options.isDynamic ?? defaultIsDynamic;

                // Initialiser la physique et le collider uniquement si fournis
                this.physics = options.physics ? Object.assign({}, options.physics) : null;
                if (this.physics) {
                    this.body = new CANNON.Body({
                        mass: this.physics.mass,
                        position: new CANNON.Vec3(
                            this.transform.position.x,
                            this.transform.position.y,
                            this.transform.position.z
                        ),
                        material: new CANNON.Material({ friction: this.physics.friction }),
                        quaternion: new CANNON.Quaternion().setFromEuler(
                            this.transform.rotation.x,
                            this.transform.rotation.y,
                            this.transform.rotation.z,
                            'XYZ'
                        ),
                        collisionFilterGroup: COLLISION_GROUP_OBJECT,
                        collisionFilterMask: COLLISION_GROUP_PLAYER | COLLISION_GROUP_OBJECT
                    });

                    if (options.collider) {
                        this.collider = Object.assign({}, options.collider);
                        this.setCollider();
                    }

                    this.world.addBody(this.body);
                } else {
                    this.body = null;
                }

                // Charger ou créer le modèle visuel
                this.initVisual();

                // Ajouter l'objet aux objets dynamiques de la scène
                if (this.isDynamic) {
                    this.game.dynamicObjects.push(this);
                }

                // Indique si l'objet est actuellement attrapé
                this.isGrabbed = false;
            }

            setCollider() {
                const { type, size } = this.collider;
                let shape;
                switch (type) {
                    case 'sphere':
                        shape = new CANNON.Sphere(size.x / 2);
                        break;
                    case 'cylinder':
                        shape = new CANNON.Cylinder(size.x / 2, size.x / 2, size.y, 12);
                        break;
                    case 'box':
                    default:
                        shape = new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));
                }
                this.body.addShape(shape);
            }

            initVisual() {
                const { color, opacity, texture, repeating, repeatDimensions, shapeType } = this.appearance;
                const { size } = this.transform;

                // Création du matériau
                const materialOptions = {
                    color: color,
                    transparent: opacity < 1,
                    opacity: opacity
                };

                if (texture) {
                    const textureLoader = new THREE.TextureLoader();
                    const loadedTexture = textureLoader.load(texture);
                    if (repeating) {
                        loadedTexture.wrapS = loadedTexture.wrapT = THREE.RepeatWrapping;
                        loadedTexture.repeat.set(repeatDimensions.x, repeatDimensions.y);
                    }
                    materialOptions.map = loadedTexture;
                }

                const material = new THREE.MeshStandardMaterial(materialOptions);

                // Création du maillage
                if (this.model.path) {
                    const loader = new THREE.GLTFLoader();
                    loader.load(this.model.path, (gltf) => {
                        this.mesh = gltf.scene;
                        this.mesh.userData.gameObject = this;
                        this.applyTransformations();
                        this.scene.add(this.mesh);

                        // Associer le corps physique aux maillages enfants
                        if (this.body) {
                            this.mesh.traverse((child) => {
                                if (child.isMesh) {
                                    child.userData.body = this.body;
                                }
                            });
                        }

                        if (this.body) {
                            this.addColliderHelper();
                        }
                    });
                } else {
                    this.createDefaultMesh(shapeType, material, size);
                }
            }

            createDefaultMesh(shapeType, material, size) {
                switch (shapeType) {
                    case 'sphere':
                        this.mesh = new THREE.Mesh(new THREE.SphereGeometry(size.x / 2, 32, 32), material);
                        break;
                    case 'cylinder':
                        this.mesh = new THREE.Mesh(
                            new THREE.CylinderGeometry(size.x / 2, size.x / 2, size.y, 12),
                            material
                        );
                        break;
                    case 'box':
                    default:
                        this.mesh = new THREE.Mesh(new THREE.BoxGeometry(size.x, size.y, size.z), material);
                }
                this.mesh.userData.gameObject = this;
                this.applyTransformations();
                this.scene.add(this.mesh);

                if (this.body) {
                    this.mesh.userData.body = this.body;
                    this.addColliderHelper();
                }
            }

            applyTransformations() {
                if (this.mesh) {
                    this.mesh.position.set(
                        this.transform.position.x,
                        this.transform.position.y,
                        this.transform.position.z
                    );
                    this.mesh.rotation.set(
                        this.transform.rotation.x,
                        this.transform.rotation.y,
                        this.transform.rotation.z
                    );
                    if (this.body) {
                        this.mesh.position.copy(this.body.position);
                        this.mesh.quaternion.copy(this.body.quaternion);
                    }
                }
            }

            addColliderHelper() {
                if (!this.body || !this.body.shapes[0]) return;

                let geometry;
                const shape = this.body.shapes[0];
                switch (shape.type) {
                    case CANNON.Shape.types.BOX:
                        const halfExtents = shape.halfExtents;
                        geometry = new THREE.BoxGeometry(
                            halfExtents.x * 2,
                            halfExtents.y * 2,
                            halfExtents.z * 2
                        );
                        break;
                    case CANNON.Shape.types.SPHERE:
                        const radius = shape.radius;
                        geometry = new THREE.SphereGeometry(radius, 16, 16);
                        break;
                    case CANNON.Shape.types.CYLINDER:
                        const radiusTop = shape.radiusTop;
                        const radiusBottom = shape.radiusBottom;
                        const height = shape.height;
                        geometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, 16);
                        break;
                    default:
                        console.warn('Type de forme non reconnu pour la visualisation du collider.');
                        return;
                }
                const material = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const helper = new THREE.Mesh(geometry, material);
                helper.name = 'ColliderHelper';
                this.scene.add(helper);

                helper.position.copy(this.body.position);
                helper.quaternion.copy(this.body.quaternion);

                if (this.body.mass > 0) {
                    this.updateColliderHelper = () => {
                        helper.position.copy(this.body.position);
                        helper.quaternion.copy(this.body.quaternion);
                    };
                }
            }

            grab() {
                this.isGrabbed = true;
            }

            ungrab() {
                this.isGrabbed = false;
            }

            update() {
                if (this.isGrabbed) return;

                if (this.body && this.mesh) {
                    this.mesh.position.copy(this.body.position);
                    this.mesh.quaternion.copy(this.body.quaternion);
                    if (this.updateColliderHelper) {
                        this.updateColliderHelper();
                    }
                }
            }
        }

        // Mise à jour de la classe Tray pour charger des modèles GLB de nourriture dynamiquement
        class Tray extends GameObject {
            constructor(options) {
                super(options);
                this.type = 'tray'; // Définir le type plateau
                this.UnhealthyCount = 0; // Compteur de malbouffe
                this.healthyFoodModels = [
                    'models/foods/soda.glb',
                    'models/foods/apple.glb',
                    'models/foods/pineapple.glb',
                    'models/foods/banana.glb',
                    'models/foods/strawberries.glb',
                    'models/foods/tomato.glb',
                    // Ajoutez les chemins vers vos modèles de nourriture saine ici
                ];

                this.unhealthyFoodModels = [
                    'models/foods/burger.glb',
                    'models/foods/hotdog.glb',
                    'models/foods/chips.glb',
                    'models/foods/pizza.glb',
                    'models/foods/donut.glb',
                    'models/foods/egg.glb',
                    'models/foods/icecream.glb',
                    'models/foods/chocolate.glb',
                    'models/foods/cupcake.glb',
                    
                    // Ajoutez les chemins vers vos modèles de nourriture non saine ici
                ];

                this.foodModels = [...this.healthyFoodModels, ...this.unhealthyFoodModels];
                this.initFood();
            }

            initFood() {
                const positions = [
                    { x: -0.5, y: 0.02, z: -0.3 },
                    { x: 0, y: 0.02, z: -0.3 },
                    { x: 0.5, y: 0.02, z: -0.3 },
                    { x: -0.5, y: 0.02, z: 0.3 },
                    { x: 0, y: 0.02, z: 0.3 },
                    { x: 0.5, y: 0.02, z: 0.3 }
                ];

                const loader = new THREE.GLTFLoader();
                const count = Math.floor(Math.random() * 6) + 1;
                const shuffled = positions.sort(() => 0.5 - Math.random()).slice(0, count);

                shuffled.forEach(position => {
                    const modelPath = this.foodModels[Math.floor(Math.random() * this.foodModels.length)];

                    const isUnhealthy = this.unhealthyFoodModels.includes(modelPath);
                    if (isUnhealthy) {
                        this.UnhealthyCount += 1;
                    }

                    loader.load(modelPath, gltf => {
                        const food = gltf.scene;
                        food.position.set(position.x, position.y, position.z);
                        this.mesh.add(food);
                    });
                });
            }
        }

        class TrayReceptor extends GameObject {
            constructor(options) {
                super(options);
            }

            update() {
                this.game.dynamicObjects.forEach(obj => {
                    const body = obj.body;
                    if (this.isInContact(body)) {
                        document.getElementById('unhealthyCount').textContent = `Unhealthy Count: ${this.game.player.UnhealthyCount}`;
                        //verifier si l'objet est de type tray et si oui, recuperer la variable de malbouffe et detruire le tray
                        if (obj.type === 'tray') {
                            // Detruire le tray
                            this.scene.remove(obj.mesh);
                            this.world.removeBody(obj.body);
                            // Ajouter la variable de malbouffe au joueur
                            this.game.player.UnhealthyCount += obj.UnhealthyCount;
                        }
                    }
                });
                super.update();
            }

            isInContact(body) {
                return this.world.contacts.some(contact => {
                    return (
                        (contact.bi === this.body && contact.bj === body) ||
                        (contact.bj === this.body && contact.bi === body)
                    );
                });
            }
        }

        class Bin extends GameObject {
            constructor(options) {
                super(options);
            }

            update() {
                this.game.dynamicObjects.forEach(obj => {
                    const body = obj.body;
                    if (this.isInContact(body)) {
                        if (obj.type === 'tray') {
                            this.scene.remove(obj.mesh);
                            this.world.removeBody(obj.body);
                            const audio = new Audio('sounds/trash.wav');
                            audio.volume = 0.3;
                            audio.play();
                        }
                    }
                });
                super.update();
            }

            isInContact(body) {
                return this.world.contacts.some(contact => {
                    return (
                        (contact.bi === this.body && contact.bj === body) ||
                        (contact.bj === this.body && contact.bi === body)
                    );
                });
            }
        }

        class ConveyorBelt extends GameObject {
            constructor(options) {
                super(options);

                this.speed = options.speed || 0.5;

                // Définir la rotation initiale
                const rotation = options.transform.rotation || new THREE.Vector3(0, 0, 0);
                const euler = new THREE.Euler(rotation.x, rotation.y, rotation.z, 'XYZ');

                // Calculer la direction basée sur la rotation initiale
                this.direction = new THREE.Vector3(1, 0, 0).applyEuler(euler).normalize();
            }

            setSpeed(newSpeed) {
                this.speed = newSpeed;
            }

            update() {
                this.game.dynamicObjects.forEach(obj => {
                    const body = obj.body;
                    if (this.isInContact(body)) {
                        // Appliquer la vélocité en fonction de la direction fixe
                        body.velocity.set(
                            this.direction.x * this.speed,
                            body.velocity.y,
                            this.direction.z * this.speed
                        );
                    }
                });
                super.update();
            }

            isInContact(body) {
                return this.world.contacts.some(contact => {
                    return (
                        (contact.bi === this.body && contact.bj === body) ||
                        (contact.bj === this.body && contact.bi === body)
                    );
                });
            }
        }

        class IntervalExecutor {
            constructor(callback, interval) {
                this.callback = callback;
                this.interval = interval;
                this.timerId = null;
                this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
                this.start();
                document.addEventListener('visibilitychange', this.handleVisibilityChange);
            }

            start() {
                this.stop(); // Ensure no multiple timers
                if (!document.hidden) {
                    this.timerId = setInterval(this.callback, this.interval);
                }
            }

            stop() {
                if (this.timerId !== null) {
                    clearInterval(this.timerId);
                    this.timerId = null;
                }
            }

            setIntervalTime(newInterval) {
                this.interval = newInterval;
                this.start();
            }

            handleVisibilityChange() {
                if (document.hidden) {
                    this.stop();
                } else {
                    this.start();
                }
            }
        }

        // Classe représentant le joueur
        class Player {
            constructor(options) {
                this.scene = options.scene;
                this.world = options.world;
                this.renderer = options.renderer;
                this.input = options.input;
                this.eventEmitter = options.eventEmitter;
                this.cameraGroup = new THREE.Group();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.y = 1.6;
                this.cameraGroup.add(this.camera);
                this.scene.add(this.cameraGroup);

                // Initialiser le joueur
                this.UnhealthyCount = 0;

                // Corps physique du joueur
                this.playerBody = new CANNON.Body({
                    mass: 1,
                    shape: new CANNON.Sphere(0.5),
                    position: new CANNON.Vec3(0, 1.6, 0),
                    material: new CANNON.Material({ friction: 0.3 }),
                    collisionFilterGroup: COLLISION_GROUP_PLAYER,
                    collisionFilterMask: COLLISION_GROUP_OBJECT // Collide uniquement avec les objets
                });
                this.world.addBody(this.playerBody);

                // Variables de contrôle
                this.yaw = 0;
                this.pitch = 0;
                this.grabbedObject = null;
                this.grabbedMesh = null; // Référence au maillage de l'objet grabé

                // Initialisation des contrôles de la souris
                this.initMouseControls();

                // Ajout des écouteurs de clic de souris pour le grab/ungrab
                this.initMouseClick();

                // Ajout d'un helper pour visualiser le corps physique du joueur
                this.addPlayerHelper();

                // Initialisation du son de déplacement
                this.movementSound = new Audio('sounds/footsteps.mp3');
                this.movementSound.loop = true;
                this.isMovementSoundPlaying = false;
            }

            initMouseControls() {
                document.addEventListener('mousemove', (event) => {
                    if (document.pointerLockElement === this.renderer.domElement) {
                        this.yaw -= event.movementX * 0.002;
                        this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch - event.movementY * 0.002));
                        this.cameraGroup.rotation.y = this.yaw;
                        this.camera.rotation.x = this.pitch;
                    }
                });
            }

            initMouseClick() {
                document.addEventListener('mousedown', (event) => {
                    if (event.button === 0) { // Clic gauche
                        this.tryGrabObject();
                    }
                });

                document.addEventListener('mouseup', (event) => {
                    if (event.button === 0) { // Clic gauche
                        this.ungrabObject();
                    }
                });
            }

            addPlayerHelper() {
                // Créer un helper pour visualiser le corps physique du joueur
                const sphereGeometry = new THREE.SphereGeometry(this.playerBody.shapes[0].radius, 16, 16);
                const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
                this.playerHelper = new THREE.Mesh(sphereGeometry, sphereMaterial);
                this.scene.add(this.playerHelper);
            }

            updatePlayerHelper() {
                if (this.playerHelper) {
                    this.playerHelper.position.copy(this.playerBody.position);
                }
            }

            update() {
                this.handleMovement();
                this.updateCameraPosition();

                // Mise à jour du helper
                this.updatePlayerHelper();
            }

            handleMovement() {
                const direction = new THREE.Vector3(
                    (this.input.isKeyPressed('q') ? -1 : 0) + (this.input.isKeyPressed('d') ? 1 : 0),
                    0,
                    (this.input.isKeyPressed('z') ? -1 : 0) + (this.input.isKeyPressed('s') ? 1 : 0)
                ).applyAxisAngle(new THREE.Vector3(0, 1, 0), this.yaw);

                // Appliquer la vélocité directement
                this.playerBody.velocity.x = direction.x * 2;
                this.playerBody.velocity.z = direction.z * 2;

                const isMoving = direction.length() > 0;
                if (isMoving && !this.isMovementSoundPlaying) {
                    this.movementSound.play();
                    this.isMovementSoundPlaying = true;
                } else if (!isMoving && this.isMovementSoundPlaying) {
                    this.movementSound.pause();
                    this.isMovementSoundPlaying = false;
                }
            }

            updateCameraPosition() {
                this.cameraGroup.position.copy(this.playerBody.position);
            }

            tryGrabObject() {
                if (this.grabbedObject) return; // Déjà un objet attrapé

                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2(0, 0); // Centre de l'écran

                raycaster.setFromCamera(mouse, this.camera);
                raycaster.far = 2.5; // Limiter la distance de grab à 1 mètre

                // Collecte de tous les maillages qui pourraient être attrapés
                const objectsToIntersect = [];
                this.scene.traverse((child) => {
                    if (child.isMesh && child.userData && child.userData.body && child.userData.body.mass > 0) {
                        objectsToIntersect.push(child);
                    }
                });

                const intersects = raycaster.intersectObjects(objectsToIntersect, true);
                for (let intersect of intersects) {
                    const object = intersect.object;

                    if (object.userData && object.userData.body && object.userData.body.mass > 0) {
                        this.grabbedObject = object.userData.body;
                        this.grabbedMesh = object; // Stocker la référence au maillage

                        // Désactiver la physique de l'objet
                        this.disablePhysics(this.grabbedObject);

                        // Marquer l'objet comme attrapé
                        if (this.grabbedMesh.userData.gameObject) {
                            this.grabbedMesh.userData.gameObject.grab();
                        }

                        // Attacher le maillage à la caméra
                        this.attachMeshToCamera(this.grabbedMesh);

                        console.log('Objet attrapé:', object);
                        break;
                    }
                }
            }

            ungrabObject() {
                if (!this.grabbedObject) return; // Aucun objet à libérer

                // Détacher le maillage de la caméra
                this.detachMeshFromCamera(this.grabbedMesh);

                // Réactiver la physique de l'objet
                this.enablePhysics(this.grabbedObject);

                // Marquer l'objet comme libéré
                if (this.grabbedMesh.userData.gameObject) {
                    this.grabbedMesh.userData.gameObject.ungrab();
                }

                console.log('Objet libéré');

                // Réinitialiser les références
                this.grabbedObject = null;
                this.grabbedMesh = null;
            }

            disablePhysics(body) {
                // Enlever le corps du monde physique
                this.world.removeBody(body);
            }

            enablePhysics(body) {
                // Réajouter le corps au monde physique
                this.world.addBody(body);
                body.velocity.set(0, 0, 0); // Réinitialiser la vélocité
                body.angularVelocity.set(0, 0, 0);
            }

            attachMeshToCamera(mesh) {
                // Positionner l'objet à une distance fixe devant la caméra
                const grabDistance = 1.5; // Distance devant la caméra
                mesh.position.set(0, 0, -grabDistance);

                // Définir la rotation pour qu'elle soit alignée avec la caméra
                mesh.quaternion.set(0, 0, 0, 1);

                // Ajouter le maillage à la caméra pour qu'il suive automatiquement les mouvements de la caméra
                this.camera.add(mesh);
            }

            detachMeshFromCamera(mesh) {
                // Mettre à jour la position mondiale avant de détacher
                mesh.updateMatrixWorld(true);

                // Obtenir la position mondiale du maillage
                const position = new THREE.Vector3();
                mesh.getWorldPosition(position);

                // Retirer le maillage de la caméra et l'ajouter à la scène
                this.camera.remove(mesh);
                this.scene.add(mesh);

                // Mettre à jour la position du corps physique
                this.grabbedObject.position.set(position.x, position.y, position.z);

                // Réorienter le corps physique pour correspondre à la rotation du maillage
                const rotation = new THREE.Quaternion();
                mesh.getWorldQuaternion(rotation);
                this.grabbedObject.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
            }
        }

        // Classe principale du jeu
        class Game {
            constructor() {
                this.eventEmitter = new EventEmitter();
                this.sceneManager = new SceneManager();
                this.physicsManager = new PhysicsManager();
                this.inputManager = new InputManager();
                this.dynamicObjects = [];
                this.conveyorBelts = [];

                this.initInstructions();
                this.initWorld();
                this.initSounds();
                this.player = new Player({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    renderer: this.sceneManager.renderer,
                    input: this.inputManager,
                    eventEmitter: this.eventEmitter
                });

                // Gérer le redimensionnement de la fenêtre
                window.addEventListener('resize', this.onWindowResize.bind(this));

                this.animate = this.animate.bind(this);

                // Paramètres pour l'incrément de la vitesse des tapis roulants
                this.conveyorSpeed = 0.5; // Vitesse initiale (units/s)

                // Initialiser le générateur de trays avec une intervalle initiale
                this.trayGenerationInterval = 4000; // Intervalle initial en ms

                // Définir la distance désirée entre les plateaux en unités
                const distanceDesiree = 1.5;

                // Définir l'incrément de vitesse des tapis roulants
                const incrementVitesse = 0.2;

                // Définir la vitesse maximale des tapis roulants
                const vitesseMax = 4;

                this.trayGenerator = new IntervalExecutor(() => {
                    new Tray({
                        scene: this.sceneManager.scene,
                        world: this.physicsManager.world,
                        game: this,
                        isDynamic: true,
                        transform: {
                            position: { x: -5, y: 1, z: -7 },
                            size: { x: 1.4, y: 0.05, z: 1 }
                        },
                        physics: {
                            mass: 1,
                            friction: 0.3,
                        },
                        appearance: {
                            color: 0xF1F1FF,
                            shapeType: 'box',
                            opacity: 1
                        },
                        collider: {
                            type: 'box',
                            size: { x: 1.4, y: 0.05, z: 1 }
                        }
                    });
                }, this.trayGenerationInterval);

                // Mettre à jour la vitesse des tapis roulants et l'intervalle de génération des plateaux pour maintenir une distance constante
                new IntervalExecutor(() => {
                    // Augmenter la vitesse des tapis roulants
                    this.conveyorSpeed = Math.min(this.conveyorSpeed + incrementVitesse, vitesseMax);

                    // Mettre à jour la vitesse de tous les tapis roulants
                    this.conveyorBelts.forEach(tapis => {
                        tapis.setSpeed(this.conveyorSpeed);
                    });

                    // Calculer le nouvel intervalle de génération des plateaux pour maintenir la distance désirée
                    this.trayGenerationInterval = (distanceDesiree / this.conveyorSpeed) * 1000; // en ms

                    // Mettre à jour l'intervalle du générateur de plateaux
                    this.trayGenerator.setIntervalTime(this.trayGenerationInterval);
                }, 1000);
            }

            initInstructions() {
                const instructions = document.getElementById('instructions');
                instructions.addEventListener('click', () => {
                    this.sceneManager.renderer.domElement.requestPointerLock();
                    instructions.style.display = 'none';
                });
            }

            initWorld() {

                // Ajouter les murs, le sol et le plafond pour créer une salle fermée
                const wallThickness = 0.5;
                const floorThickness = wallThickness;
                const roomSize = { x: 12, y: 5, z: 15 };
                const roomCenter = { x: -0.5, y: 2, z: -2 };

                // Création du sol
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: roomCenter.x,
                            y: roomCenter.y - roomSize.y / 2 + floorThickness / 2,
                            z: roomCenter.z
                        },
                        size: { x: roomSize.x, y: floorThickness, z: roomSize.z }
                    },
                    physics: {
                        mass: 0,
                        friction: 0.5
                    },
                    appearance: {
                        texture: 'textures/floor.jpg',
                        repeating: true,
                        repeatDimensions: { x: 2, y: 2 },
                        shapeType: 'box',
                        opacity: 1
                    },
                    collider: {
                        type: 'box',
                        size: { x: roomSize.x, y: floorThickness, z: roomSize.z }
                    }
                });

                // Mur arrière
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: roomCenter.x,
                            y: roomCenter.y,
                            z: roomCenter.z - roomSize.z / 2 - wallThickness / 2
                        },
                        size: { x: roomSize.x, y: roomSize.y, z: wallThickness }
                    },
                    physics: {
                        mass: 0
                    },
                    appearance: {
                        color: 0x9e9e9e,
                        shapeType: 'box'
                    },
                    collider: {
                        type: 'box',
                        size: { x: roomSize.x, y: roomSize.y, z: wallThickness }
                    }
                });

                // Mur avant
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: roomCenter.x,
                            y: roomCenter.y,
                            z: roomCenter.z + roomSize.z / 2 + wallThickness / 2
                        },
                        size: { x: roomSize.x, y: roomSize.y, z: wallThickness }
                    },
                    physics: {
                        mass: 0
                    },
                    appearance: {
                        color: 0x5e5e5e,
                        shapeType: 'box'
                    },
                    collider: {
                        type: 'box',
                        size: { x: roomSize.x, y: roomSize.y, z: wallThickness }
                    }
                });

                // Mur gauche
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: roomCenter.x - roomSize.x / 2 - wallThickness / 2,
                            y: roomCenter.y,
                            z: roomCenter.z
                        },
                        size: { x: wallThickness, y: roomSize.y, z: roomSize.z }
                    },
                    physics: {
                        mass: 0
                    },
                    appearance: {
                        color: 0x5e5e5e,
                        shapeType: 'box'
                    },
                    collider: {
                        type: 'box',
                        size: { x: wallThickness, y: roomSize.y, z: roomSize.z }
                    }
                });

                // Mur droit
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: roomCenter.x + roomSize.x / 2 + wallThickness / 2,
                            y: roomCenter.y,
                            z: roomCenter.z
                        },
                        size: { x: wallThickness, y: roomSize.y, z: roomSize.z }
                    },
                    physics: {
                        mass: 0
                    },
                    appearance: {
                        color: 0x5e5e5e,
                        shapeType: 'box'
                    },
                    collider: {
                        type: 'box',
                        size: { x: wallThickness, y: roomSize.y, z: roomSize.z }
                    }
                });

                // Plafond
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: roomCenter.x,
                            y: roomCenter.y + roomSize.y / 2 - floorThickness / 2,
                            z: roomCenter.z
                        },
                        size: { x: roomSize.x, y: floorThickness, z: roomSize.z }
                    },
                    physics: {
                        mass: 0
                    },
                    appearance: {
                        color: 0xcccccc,
                        shapeType: 'box'
                    },
                    collider: {
                        type: 'box',
                        size: { x: roomSize.x, y: floorThickness, z: roomSize.z }
                    }
                });

                // Front wall window
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: 5,
                            y: 0.2,
                            z: 5.4
                        },
                        size: { x: 2, y: 2, z: 0.1 }
                    },
                    model: {
                        path: 'models/environments/window.glb'
                    }
                });

                // Right wall window
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: -6.5,
                            y: 0.2,
                            z: -7
                        },
                        size: { x: 2, y: 2, z: 0.1 },
                        rotation: { x: 0, y: Math.PI / 2, z: 0 }
                    },
                    model: {
                        path: 'models/environments/window.glb'
                    }
                });

                // Back wall door
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: roomCenter.x,
                            y: -0.1,
                            z: -9.69
                        },
                        size: { x: 1, y: 2, z: 0.1 }
                    },
                    model: {
                        path: 'models/environments/door.glb'
                    }
                });

                // light
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: { x: -0.5, y: 3.4, z: -2 },
                        size: { x: 1, y: 2, z: 0.1 }
                    },
                    model: {
                        path: 'models/environments/light.glb'
                    }
                });

                // Création d'un plateau récepteur
                new TrayReceptor({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    isDynamic: true,
                    transform: {
                        position: { x: 4, y: 1.5, z: -9.4 },
                        size: { x: 0.1, y: 2, z:2 },
                        rotation: { x: 0, y: Math.PI / 2, z: 0 }
                    },
                    physics: {
                        mass: 0
                    },
                    appearance: {
                        color: 0x000000, // Vert
                        shapeType: 'box',
                        opacity: 1
                    },
                    collider: {
                        type: 'box',
                        size: { x: 0.1, y: 2, z:2 },
                    }
                });

                // Création d'une poubelle
                new Bin({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    isDynamic: true,
                    transform: {
                        position: { x: -0.5, y: 0.75, z: -2 },
                        size: { x: 1, y: 1.5, z: 0.5 },
                        rotation: { x: 0, y: 0, z: 0 }
                    },
                    physics: {
                        mass: 0
                    },
                    model: {
                        path: 'models/environments/trash.glb'
                    },
                    collider: {
                        type: 'box',
                        size: { x: 1, y: 1.5, z: 0.5 }
                    }
                });

                // Tapis roulant du côté gauche du U
                const conveyorBelt1 = new ConveyorBelt({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    isDynamic: true,
                    transform: {
                        position: { x: -5, y: 0.5, z: -2.5 }, // Position décalée à gauche
                        rotation: { x: 0, y: -Math.PI / 2, z: 0 }, // Orientation verticale
                        size: { x: 10, y: 1.5, z: 2 } // Taille du tapis
                    },
                    appearance: {
                        color: 0x000000,
                        opacity: 1,
                        shapeType: 'box'
                    },
                    physics: {
                        mass: 0,
                        friction: 0,
                    },
                    collider: {
                        type: 'box',
                        size: { x: 10, y: 1.5, z: 2 }
                    },
                    speed: this.conveyorSpeed,
                });

                const conveyorBelt2 = new ConveyorBelt({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    isDynamic: true,
                    transform: {
                        position: { x: -1, y: 0.499, z: 3 }, // Position centrale
                        size: { x: 10, y: 1.5, z: 2 },    // Taille du tapis
                        rotation: { x: 0, y: 0, z: 0 }   // Orientation horizontale
                    },
                    appearance: {
                        color: 0x000000,
                        opacity: 1,
                        shapeType: 'box'
                    },
                    physics: {
                        mass: 0,
                        friction: 0,
                    },
                    collider: {
                        type: 'box',
                        size: { x: 10, y: 1.5, z: 2 }
                    },
                    speed: this.conveyorSpeed,
                });

                const conveyorBelt3 = new ConveyorBelt({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    isDynamic: true,
                    transform: {
                        position: { x: 4, y: 0.498, z: -3 }, // Position décalée à gauche
                        size: { x: 14, y: 1.5, z: 2 },        // Taille du tapis
                        rotation: { x: 0, y: Math.PI / 2, z: 0 } // Orientation verticale
                    },
                    appearance: {
                        color: 0x000000,
                        opacity: 1,
                        shapeType: 'box'
                    },
                    physics: {
                        mass: 0,
                        friction: 0,
                    },
                    collider: {
                        type: 'box',
                        size: { x: 14, y: 1.5, z: 2 },        // Taille du tapis
                    },
                    speed: this.conveyorSpeed,
                });

                this.conveyorBelts.push(conveyorBelt1, conveyorBelt2, conveyorBelt3);

                // Création d'un décor de tapis roulant du côté gauche du U
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: { x: 4, y: 0.3, z: -2.5 },
                        size: { x: 1.4, y: 1.5, z: 2 },
                        rotation: { x: 0, y: Math.PI / 2, z: 0 }
                    },
                    model: {
                        path: 'models/environments/conveyor.glb'
                    }
                });

                // Création d'un décor de tapis roulant du coté droit du U
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: { x: -5, y: 0.3, z: -2.5 },
                        size: { x: 1.4, y: 1.5, z: 2 },
                        rotation: { x: 0, y: Math.PI / 2, z: 0 }
                    },
                    model: {
                        path: 'models/environments/conveyor.glb'
                    }
                });

                // Création d'un décor de tapis roulant de la base du U
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: { x: -0.5, y: 0.3, z: 3 },
                        size: { x: 1.4, y: 1.5, z: 2 },
                        rotation: { x: 0, y: 0, z: 0 }
                    },
                    model: {
                        path: 'models/environments/conveyor2.glb'
                    }
                });

                // Decor plateau générateur
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: { x: -5, y: -0.2, z: -6.90 },
                        size: { x: 1.4, y: 1.5, z: 2 },
                        rotation: { x: 0, y: Math.PI / 2, z: Math.PI / 2 }
                    },
                    model: {
                        path: 'models/environments/conveyor_hole.glb'
                    }
                });

                // Décor plateau récepteur
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: { x: 4, y: 1.8, z: -9 },
                        size: { x: 1.4, y: 1.5, z: 2 },
                        rotation: { x: 0, y: Math.PI / 2, z: 0 }
                    },
                    model: {
                        path: 'models/environments/conveyor_hole.glb'
                    }
                });
            }

            initSounds() {
                var audio = new Audio('sounds/conveyor.mp3');
                audio.volume = 0.06;
                audio.loop = true;
                audio.play();
            }

            animate() {
                requestAnimationFrame(this.animate);

                // Mettre à jour la physique
                this.physicsManager.step();

                // Mettre à jour tous les objets dynamiques
                this.dynamicObjects.forEach(obj => obj.update());

                // Mettre à jour le joueur
                this.player.update();

                // Rendu de la scène avec la caméra du joueur
                this.sceneManager.render(this.player.camera);
            }

            start() {
                this.animate();
            }

            onWindowResize() {
                this.player.camera.aspect = window.innerWidth / window.innerHeight;
                this.player.camera.updateProjectionMatrix();
                this.sceneManager.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Initialisation du jeu
        const game = new Game();
        game.start();
    </script>
</body>

</html>