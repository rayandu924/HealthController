<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Jeu de Douane 3D avec Three.js</title>
    <style>
        /* Styles de base */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #f0f0f0;
        }

        /* Interface Utilisateur */
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1;
            display: flex;
            flex-direction: column;
        }

        /* Informations du jeu */
        #info {
            position: relative;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            min-width: 200px;
        }

        #info p {
            margin: 5px 0;
            font-size: 16px;
        }

        /* Panneau des objets interdits */
        #forbiddenPanel {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            max-width: 250px;
            overflow-y: auto;
            max-height: 400px;
        }

        #forbiddenPanel h3 {
            margin-top: 0;
            font-size: 18px;
            margin-bottom: 10px;
            text-align: center;
        }

        .forbidden-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .forbidden-icon {
            width: 24px;
            height: 24px;
            margin-right: 12px;
            border: 1px solid #fff;
            border-radius: 4px;
            background-size: cover;
            background-position: center;
        }

        .forbidden-item span {
            font-size: 16px;
        }

        /* √âcran de blocage au d√©marrage */
        #blocker {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 28px;
            cursor: pointer;
            z-index: 2;
        }

        #blocker:hover {
            background-color: rgba(0,0,0,0.9);
        }

        /* Transition de jour */
        #dayTransition {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            color: white;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            z-index: 3;
        }

        /* Animation de gain/perte d'argent */
        .money-change {
            position: absolute;
            font-size: 20px;
            font-weight: bold;
            z-index: 4;
            pointer-events: none;
            text-shadow: 1px 1px 4px rgba(0,0,0,0.5);
            transition: all 1s ease-out;
        }
    </style>
</head>
<body>
    <!-- Interface Utilisateur -->
    <div id="ui">
        <div id="info">
            <p>üí∞ Argent: <span id="money">0</span>‚Ç¨</p>
            <p>üìÖ Jour: <span id="day">1</span></p>
            <p>üì¶ Bo√Ætes contr√¥l√©es: <span id="boxesHandled">0</span>/<span id="boxesTotal">10</span></p>
        </div>
        <!-- Panneau des Objets Interdits -->
        <div id="forbiddenPanel">
            <h3>Objets Interdits</h3>
            <div id="forbiddenList">
                <!-- Liste des objets interdits sera g√©n√©r√©e ici -->
            </div>
        </div>
    </div>

    <!-- √âcran de d√©marrage -->
    <div id="blocker">Cliquez pour commencer</div>

    <!-- Transition de jour -->
    <div id="dayTransition"></div>

    <!-- Biblioth√®ques externes -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <!-- Inclusion du GLTFLoader pour charger les fichiers GLB -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Inclusion de TWEEN.js pour les animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
        // Configuration du jeu et du mapping de la sc√®ne
        const CONFIG = {
            scene: { backgroundColor: 0x555555 },
            camera: {
                fov: 75,
                aspect: window.innerWidth / window.innerHeight,
                near: 0.1,
                far: 1000,
                position: { x: 0, y: 2.5, z: 5 }
            },
            renderer: { antialias: true },
            lighting: {
                ambient: { color: 0x404040 }
            },
            conveyorBelt: {
                size: { width: 10, height: 1, depth: 2 },
                color: 0x808080,
                position: { x: 0, y: 0.25, z: 0 },
                baseSpeed: 0.25
            },
            boxGenerator: {
                size: { width: 0.1, height: 2, depth: 2 },
                color: 0xff0000,
                position: { x: -6.05, y: 1.1, z: 0 },
                baseSpawnInterval: 5000
            },
            boxDestroyer: {
                size: { width: 0.1, height: 2, depth: 2 },
                color: 0x000000,
                position: { x: 5.05, y: 1, z: 0 }
            },
            player: { height: 2.5 },
            box: {
                dimensions: { width: 1, height: 0.5, depth: 1 },
                wallThickness: 0.05,
                velocity: { x: 0.05, y: 0, z: 0 }
            },
            boxMaterials: {
                lidColor: 0x421c01,
                wallColor: 0xa65b02,
                bottomColor: 0xe3881b
            },
            game: { 
                packagesPerDay: 10, 
                moneyPerPackage: 10,
                moneyLostPerBadBox: 20,
                forbiddenBoxProbability: 0.2
            },
            speedFactor: 1.0,
            sceneMapping: {
                objects: [
                    // Sol
                    {
                        type: 'Box',
                        options: {
                            dimensions: { width: 10, height: 0.1, depth: 5 },
                            material: new THREE.MeshPhongMaterial({ color: 0x228B22 }),
                            position: { x: 0, y: 0, z: 3.5 },
                            rotation: { x: 0, y: 0, z: 0 }
                        }
                    },
                    // Tapis roulant
                    {
                        type: 'Box',
                        options: {
                            dimensions: { width: 10, height: 1.5, depth: 2 },
                            material: new THREE.MeshPhongMaterial({ color: 0x808080 }),
                            position: { x: 0, y: 0.25, z: 0 }
                        }
                    },
                    // G√©n√©rateur de bo√Ætes
                    {
                        type: 'Box',
                        options: {
                            dimensions: { width: 0.1, height: 2, depth: 2 },
                            material: new THREE.MeshPhongMaterial({ color: 0x000000 }),
                            position: { x: -4.95, y: 1, z: -0.01 }
                        }
                    },
                    // Destructeur de bo√Ætes
                    {
                        type: 'Box',
                        options: {
                            dimensions: { width: 0.1, height: 2, depth: 2 },
                            material: new THREE.MeshPhongMaterial({ color: 0x000000 }),
                            position: { x: 4.95, y: 1, z: -0.01 }
                        }
                    },
                    // Murs et plafond
                    {
                        type: 'Box',
                        options: {
                            dimensions: { width: 10, height: 3, depth: 0.1 },
                            material: new THREE.MeshPhongMaterial({ color: 0x5e5529 }),
                            position: { x: 0, y: 1.5, z: -1 }
                        }
                    },
                    {
                        type: 'Box',
                        options: {
                            dimensions: { width: 10, height: 3, depth: 0.1 },
                            material: new THREE.MeshPhongMaterial({ color: 0x5e5529 }),
                            position: { x: 0, y: 1.5, z: 6 }
                        }
                    },
                    {
                        type: 'Box',
                        options: {
                            dimensions: { width: 7, height: 3, depth: 0.1 },
                            material: new THREE.MeshPhongMaterial({ color: 0x5e5529 }),
                            position: { x: 5, y: 1.5, z: 2.55 },
                            rotation: { x: 0, y: Math.PI/2, z: 0 }
                        }
                    },
                    {
                        type: 'Box',
                        options: {
                            dimensions: { width: 7, height: 3, depth: 0.1 },
                            material: new THREE.MeshPhongMaterial({ color: 0x5e5529 }),
                            position: { x: -5, y: 1.5, z: 2.55 },
                            rotation: { x: 0, y: Math.PI/2, z: 0 }
                        }
                    },
                    // Plafond
                    {
                        type: 'Box',
                        options: {
                            dimensions: { width: 10, height: 0.1, depth: 7 },
                            material: new THREE.MeshPhongMaterial({ color: 0x228B22 }),
                            position: { x: 0, y: 3, z: 2.5 },
                            rotation: { x: 0, y: 0, z: 0 }
                        }
                    },
                ]
            },
            forbiddenObjects: [], // √Ä d√©finir dynamiquement
            objectPool: [] // Liste des objets pr√©d√©finis
        };

        /**
         * Fonction pour pr√©charger les mod√®les 3D
         * @param {Array} models - Tableau des mod√®les √† charger
         * @returns {Promise<void>}
         */
        function preloadModels(models) {
            const loader = new THREE.GLTFLoader();
            const promises = models.map(model => {
                return new Promise((resolve, reject) => {
                    loader.load(model.path, gltf => {
                        model.gltf = gltf;
                        resolve();
                    }, undefined, error => {
                        console.error(`Erreur lors du chargement du mod√®le: ${model.path}`, error);
                        resolve(); // Continuer m√™me si un mod√®le √©choue √† charger
                    });
                });
            });
            return Promise.all(promises);
        }

        /**
         * Fonction utilitaire pour obtenir un √©l√©ment al√©atoire d'un tableau
         * @param {Array} array - Tableau d'√©l√©ments
         * @returns {*} - √âl√©ment al√©atoire du tableau
         */
        function getRandomElement(array) {
            return array[Math.floor(Math.random() * array.length)];
        }

        /**
         * Classe pour mapper la sc√®ne avec des objets de d√©coration.
         */
        class SceneMapper {
            constructor(scene, mapperConfig) {
                this.scene = scene;
                this.mapperConfig = mapperConfig;
                this.init();
            }

            init() {
                this.mapperConfig.objects.forEach(objConfig => {
                    const obj = createObject(objConfig.type, objConfig.options);
                    this.scene.add(obj);
                });
            }
        }

        /**
         * Fonction utilitaire pour cr√©er des objets g√©om√©triques (si n√©cessaire)
         * @param {string} type - Type de l'objet (Box, Sphere, etc.)
         * @param {object} options - Options de configuration de l'objet
         * @returns {THREE.Mesh} - L'objet cr√©√©
         */
        function createObject(type, options = {}) {
            let geometry;
            switch (type) {
                case 'Box':
                    geometry = new THREE.BoxGeometry(
                        options.dimensions?.width || 0.5,
                        options.dimensions?.height || 0.5,
                        options.dimensions?.depth || 0.5
                    );
                    break;
                case 'Sphere':
                    geometry = new THREE.SphereGeometry(
                        options.radius || 0.25,
                        options.widthSegments || 16,
                        options.heightSegments || 16
                    );
                    break;
                case 'Cylinder':
                    geometry = new THREE.CylinderGeometry(
                        options.radiusTop || 0.25,
                        options.radiusBottom || 0.25,
                        options.height || 0.5,
                        options.radialSegments || 16
                    );
                    break;
                case 'Cone':
                    geometry = new THREE.ConeGeometry(
                        options.radius || 0.25,
                        options.height || 0.5,
                        options.radialSegments || 16
                    );
                    break;
                case 'Torus':
                    geometry = new THREE.TorusGeometry(
                        options.radius || 0.25,
                        options.tube || 0.1,
                        options.radialSegments || 16,
                        options.tubularSegments || 32
                    );
                    break;
                default:
                    console.warn(`Type de g√©om√©trie inconnu: ${type}`);
                    geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            }

            const material = options.material || new THREE.MeshPhongMaterial({ color: options.color || 0xffffff });
            const mesh = new THREE.Mesh(geometry, material);

            if (options.position) {
                mesh.position.set(
                    options.position.x || 0,
                    options.position.y || 0,
                    options.position.z || 0
                );
            }

            if (options.rotation) {
                mesh.rotation.set(
                    options.rotation.x || 0,
                    options.rotation.y || 0,
                    options.rotation.z || 0
                );
            }

            if (options.scale) {
                mesh.scale.set(
                    options.scale.x || 1,
                    options.scale.y || 1,
                    options.scale.z || 1
                );
            }

            if (options.name) {
                mesh.name = options.name;
            }

            if (options.userData) {
                mesh.userData = options.userData;
            }

            return mesh;
        }

        /**
         * Classe repr√©sentant une bo√Æte dans le jeu.
         */
        class Box {
            constructor(position, dimensions, wallThickness, scene, conveyorSpeed, forbiddenObjects, isForbiddenBox, objectPool) {
                this.group = new THREE.Group();
                this.dimensions = dimensions;
                this.wallThickness = wallThickness;
                this.velocity = new THREE.Vector3(conveyorSpeed, 0, 0);
                this.forbiddenObjects = forbiddenObjects;
                this.isForbiddenBox = isForbiddenBox;
                this.isForbidden = false;
                this.objectPool = objectPool;

                // Cr√©ation des murs
                this.createWalls();

                // Cr√©ation du couvercle
                this.createLid();

                // Ajout d'objets
                this.addObjects();

                // Positionnement initial
                this.group.position.set(position.x, position.y + 0.25, position.z);
                this.group.userData.velocity = this.velocity;

                // Ajout √† la sc√®ne
                scene.add(this.group);
            }

            createWalls() {
                const { width, height, depth } = this.dimensions;
                const t = this.wallThickness;
                const wallMaterial = new THREE.MeshPhongMaterial({ color: CONFIG.boxMaterials.wallColor });
                const halfWidth = width / 2;
                const halfDepth = depth / 2;
                const halfHeight = height / 2;

                const walls = [
                    // Front
                    {
                        type: 'Box',
                        options: {
                            dimensions: { width: width + t * 2, height, depth: t },
                            material: wallMaterial,
                            position: { x: 0, y: 0, z: halfDepth + t / 2 }
                        }
                    },
                    // Back
                    {
                        type: 'Box',
                        options: {
                            dimensions: { width: width + t * 2, height, depth: t },
                            material: wallMaterial,
                            position: { x: 0, y: 0, z: -halfDepth - t / 2 }
                        }
                    },
                    // Left
                    {
                        type: 'Box',
                        options: {
                            dimensions: { width: t, height, depth: depth + t * 2 },
                            material: wallMaterial,
                            position: { x: -halfWidth - t / 2, y: 0, z: 0 }
                        }
                    },
                    // Right
                    {
                        type: 'Box',
                        options: {
                            dimensions: { width: t, height, depth: depth + t * 2 },
                            material: wallMaterial,
                            position: { x: halfWidth + t / 2, y: 0, z: 0 }
                        }
                    },
                    // Bottom
                    {
                        type: 'Box',
                        options: {
                            dimensions: { width: width + t * 2, height: t, depth: depth + t * 2 },
                            material: new THREE.MeshPhongMaterial({ color: CONFIG.boxMaterials.bottomColor }),
                            position: { x: 0, y: -halfHeight - t / 2, z: 0 }
                        }
                    }
                ];

                walls.forEach(wallConfig => {
                    const wall = createObject(wallConfig.type, wallConfig.options);
                    this.group.add(wall);
                });
            }

            createLid() {
                const { width, height, depth } = this.dimensions;
                const t = this.wallThickness;
                const lid = createObject('Box', {
                    dimensions: { width: width + t * 2, height: t, depth: depth + t * 2 },
                    material: new THREE.MeshPhongMaterial({ color: CONFIG.boxMaterials.lidColor }),
                    position: { x: 0, y: height / 2 + t / 2, z: 0 },
                    name: 'lid'
                });
                this.group.add(lid);
            }

            isObjectForbidden(poolObject) {
                return this.forbiddenObjects.some(obj => obj.name === poolObject.name);
            }

            getNonForbiddenObjects() {
                return this.objectPool.filter(obj => !this.isObjectForbidden(obj));
            }

            addObjects() {
                const numObjects = THREE.MathUtils.randInt(1, 3);
                let hasForbiddenObject = false;

                const allowedObjects = this.objectPool.filter(obj => obj.category === 'allowed');
                const forbiddenObjects = this.objectPool.filter(obj => obj.category === 'forbidden');

                const positions = [
                    { x: -0.25, y: -0.15, z: -0.35 }, // Haut gauche
                    { x: 0.25, y: -0.15, z: -0.35 },  // Haut droite
                    { x: -0.25, y: -0.15, z: 0 },     // Milieu gauche
                    { x: 0.25, y: -0.15, z: 0 },      // Milieu droite
                    { x: -0.25, y: -0.15, z: 0.35 },  // Bas gauche
                    { x: 0.25, y: -0.15, z: 0.35 }    // Bas droite
                ];

                // M√©langer les positions pour les s√©lectionner al√©atoirement
                const shuffledPositions = positions.sort(() => Math.random() - 0.5);

                for (let i = 0; i < numObjects; i++) {
                    let poolObject;

                    if (this.isForbiddenBox && !hasForbiddenObject && i === numObjects - 1) {
                        // S'assurer qu'au moins un objet interdit est ajout√©
                        poolObject = getRandomElement(forbiddenObjects);
                        hasForbiddenObject = true;
                    } else {
                        if (this.isForbiddenBox && Math.random() < 0.5) {
                            poolObject = getRandomElement(forbiddenObjects);
                            hasForbiddenObject = true;
                        } else {
                            poolObject = getRandomElement(allowedObjects);
                        }
                    }

                    // Obtenir une position disponible
                    const position = shuffledPositions.pop();
                    if (!position) break; // Plus de positions disponibles

                    // Cloner le mod√®le pour √©viter les r√©f√©rences partag√©es
                    const modelClone = poolObject.gltf.scene.clone();

                    // Positionnement relatif √† la bo√Æte
                    modelClone.position.set(position.x, position.y, position.z);
                    modelClone.scale.set(0.4, 0.4, 0.4);

                    // Marquer l'objet comme interdit si n√©cessaire
                    modelClone.userData.isForbidden = poolObject.category === 'forbidden';

                    this.group.add(modelClone);
                }

                this.isForbidden = hasForbiddenObject;
            }

            update(delta) {
                this.group.position.add(this.velocity.clone().multiplyScalar(delta));
            }

            isOutOfBounds(destroyPositionX) {
                return this.group.position.x > destroyPositionX;
            }

            removeFromScene(scene) {
                scene.remove(this.group);
            }
        }

        /**
         * Classe principale du jeu.
         */
        class Game {
            constructor(config) {
                this.config = config;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.boxes = [];
                this.money = 0;
                this.day = 1;
                this.packagesHandled = 0;
                this.packagesGenerated = 0;
                this.boxGenerator = { ...config.boxGenerator, elapsedTime: 0 };
                this.move = { forward: false, backward: false, left: false, right: false };
                this.velocityPlayer = new THREE.Vector3();
                this.direction = new THREE.Vector3();
                this.forbiddenObjectsList = [];
                this.clock = new THREE.Clock();
                this.objectPool = []; // Liste des mod√®les charg√©s

                this.init();
            }

            async init() {
                this.setupScene();
                this.setupCamera();
                this.setupRenderer();
                this.setupLighting();
                this.setupControls();
                this.setupEventListeners();

                // Charger les mod√®les depuis les listes d√©finies directement dans le code
                await this.setupObjectPool();

                this.setupForbiddenObjects();
                this.sceneMapper = new SceneMapper(this.scene, this.config.sceneMapping);
                this.updatePackagesPerDay();
                this.updateUI();
                this.showDayTransition();
                this.animate();
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(this.config.scene.backgroundColor);
            }

            setupCamera() {
                const { fov, aspect, near, far, position } = this.config.camera;
                this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
                this.camera.position.set(position.x, position.y, position.z);
            }

            setupRenderer() {
                const { antialias } = this.config.renderer;
                this.renderer = new THREE.WebGLRenderer({ antialias });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement);
            }

            setupLighting() {
                const { ambient } = this.config.lighting;

                // Lumi√®re ambiante
                const ambientLight = new THREE.AmbientLight(ambient.color);
                this.scene.add(ambientLight);

                // Lumi√®re directionnelle
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(0, 10, 5);
                this.scene.add(directionalLight);
            }

            setupControls() {
                this.controls = new THREE.PointerLockControls(this.camera, document.body);
                const blocker = document.getElementById('blocker');

                blocker.addEventListener('click', () => this.controls.lock(), false);

                this.controls.addEventListener('lock', () => {
                    blocker.style.display = 'none';
                });

                this.controls.addEventListener('unlock', () => {
                    blocker.style.display = 'flex';
                });

                this.scene.add(this.controls.getObject());
                this.controls.getObject().position.set(
                    this.config.camera.position.x,
                    this.config.player.height,
                    this.config.camera.position.z
                );
            }

            setupEventListeners() {
                window.addEventListener('resize', this.onWindowResize.bind(this), false);
                document.addEventListener('keydown', this.onKeyDown.bind(this), false);
                document.addEventListener('keyup', this.onKeyUp.bind(this), false);
                document.addEventListener('mousedown', this.onMouseDown.bind(this), false);
            }

            async setupObjectPool() {
                // D√©finir directement les listes de mod√®les autoris√©s et interdits
                const allowedModels = [
                    { name: 'Burger', path: 'models/allowed/burger.glb' },
                    // Ajoutez d'autres mod√®les autoris√©s ici
                ];

                const forbiddenModels = [
                    { name: 'Burger', path: 'models/forbidden/burger.glb' },
                    // Ajoutez d'autres mod√®les interdits ici
                ];

                // Construire objectPool en assignant la cat√©gorie √† chaque mod√®le
                this.objectPool = [
                    ...allowedModels.map(model => ({ ...model, category: 'allowed' })),
                    ...forbiddenModels.map(model => ({ ...model, category: 'forbidden' }))
                ];

                // Pr√©charger les mod√®les
                await preloadModels(this.objectPool);
            }

            setupForbiddenObjects() {
                this.forbiddenObjectsList = [];
                this.updateForbiddenObjects();
                this.updateForbiddenPanel();
            }

            updateForbiddenObjects() {
                // Ajouter un nouvel objet interdit chaque jour
                const forbiddenModels = this.objectPool.filter(obj => obj.category === 'forbidden');
                const availableObjects = forbiddenModels.filter(obj =>
                    !this.forbiddenObjectsList.some(forbidden => forbidden.name === obj.name)
                );

                if (availableObjects.length > 0) {
                    const newForbidden = getRandomElement(availableObjects);
                    this.forbiddenObjectsList.push(newForbidden);
                    this.config.forbiddenObjects = [...this.forbiddenObjectsList];
                }
            }

            updateForbiddenPanel() {
                const forbiddenList = document.getElementById('forbiddenList');
                forbiddenList.innerHTML = ''; // R√©initialiser la liste

                this.config.forbiddenObjects.forEach(obj => {
                    const item = document.createElement('div');
                    item.classList.add('forbidden-item');

                    const icon = document.createElement('div');
                    icon.classList.add('forbidden-icon');
                    icon.style.backgroundImage = `url('icons/${obj.name}.png')`;

                    const label = document.createElement('span');
                    label.innerText = obj.name;

                    item.appendChild(icon);
                    item.appendChild(label);
                    forbiddenList.appendChild(item);
                });
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            onKeyDown(event) {
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        this.move.forward = true;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        this.move.backward = true;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        this.move.left = true;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        this.move.right = true;
                        break;
                    case 'KeyE':
                        this.tryDestroyBox();
                        break;
                }
            }

            onKeyUp(event) {
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        this.move.forward = false;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        this.move.backward = false;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        this.move.left = false;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        this.move.right = false;
                        break;
                }
            }

            onMouseDown(event) {
                if (!this.controls.isLocked) return;

                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                // Pointeur au centre de l'√©cran
                mouse.x = 0;
                mouse.y = 0;

                raycaster.setFromCamera(mouse, this.camera);

                const intersects = raycaster.intersectObjects(
                    this.boxes.map(box => box.group),
                    true
                );

                if (intersects.length > 0) {
                    const intersectedBoxGroup = intersects[0].object.parent;
                    const intersectedBox = this.boxes.find(box => box.group === intersectedBoxGroup);

                    if (intersectedBox) {
                        const lid = intersectedBox.group.getObjectByName('lid');
                        if (lid) {
                            // Animation d'ouverture du couvercle
                            new TWEEN.Tween(lid.rotation)
                                .to({ x: -Math.PI / 2 }, 500)
                                .easing(TWEEN.Easing.Quadratic.Out)
                                .start()
                                .onComplete(() => {
                                    intersectedBox.group.remove(lid);
                                });
                        }
                    }
                }
            }

            tryDestroyBox() {
                if (!this.controls.isLocked) return;

                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                // Pointeur au centre de l'√©cran
                mouse.x = 0;
                mouse.y = 0;

                raycaster.setFromCamera(mouse, this.camera);

                const intersects = raycaster.intersectObjects(
                    this.boxes.map(box => box.group),
                    true
                );

                if (intersects.length > 0) {
                    const intersectedBoxGroup = intersects[0].object.parent;
                    const intersectedBox = this.boxes.find(box => box.group === intersectedBoxGroup);

                    if (intersectedBox) {
                        this.animateBoxDestruction(intersectedBox);

                        let moneyChange = 0;
                        if (intersectedBox.isForbidden) {
                            moneyChange = this.config.game.moneyPerPackage;
                        } else {
                            moneyChange = -this.config.game.moneyLostPerBadBox;
                        }

                        this.updateMoney(moneyChange);
                        this.packagesHandled++;
                        this.updateUI();

                        // Supprimer la bo√Æte du tableau
                        const index = this.boxes.indexOf(intersectedBox);
                        if (index > -1) {
                            this.boxes.splice(index, 1);
                        }

                        if (this.packagesHandled >= this.config.game.packagesPerDay && this.boxes.length === 0) {
                            this.nextDay();
                        }
                    }
                }
            }

            updateMoney(amount) {
                this.money += amount;
                this.updateUI();
                this.showMoneyChange(amount);
            }

            animateBoxDestruction(box) {
                // Animation de disparition avec rotation et r√©duction d'√©chelle
                new TWEEN.Tween(box.group.rotation)
                    .to({ y: box.group.rotation.y + Math.PI * 2 }, 1000)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();

                new TWEEN.Tween(box.group.scale)
                    .to({ x: 0, y: 0, z: 0 }, 1000)
                    .easing(TWEEN.Easing.Back.In)
                    .start()
                    .onComplete(() => {
                        this.scene.remove(box.group);
                    });
            }

            spawnBox() {
                if (this.packagesGenerated >= this.config.game.packagesPerDay) {
                    return;
                }

                const effectiveConveyorSpeed = this.config.conveyorBelt.baseSpeed * this.config.speedFactor;
                const isForbiddenBox = Math.random() < this.config.game.forbiddenBoxProbability;

                const box = new Box(
                    this.config.boxGenerator.position,
                    this.config.box.dimensions,
                    this.config.box.wallThickness,
                    this.scene,
                    effectiveConveyorSpeed,
                    this.config.forbiddenObjects,
                    isForbiddenBox,
                    this.objectPool
                );

                this.boxes.push(box);
                this.packagesGenerated++;
            }

            updateBoxes(delta) {
                const destroyPositionX = this.config.boxDestroyer.position.x + 0.2;

                for (let i = this.boxes.length - 1; i >= 0; i--) {
                    const box = this.boxes[i];
                    box.update(delta);

                    if (box.isOutOfBounds(destroyPositionX)) {
                        this.animateBoxDestruction(box); // Animer la destruction

                        let moneyChange = 0;
                        if (box.isForbidden) {
                            moneyChange = -this.config.game.moneyLostPerBadBox;
                        } else {
                            moneyChange = this.config.game.moneyPerPackage;
                        }
                        this.updateMoney(moneyChange);
                        this.packagesHandled++;
                        this.updateUI();

                        this.boxes.splice(i, 1);

                        if (this.packagesHandled >= this.config.game.packagesPerDay && this.boxes.length === 0) {
                            this.nextDay();
                        }
                    }
                }
            }

            updatePlayer(delta) {
                if (!this.controls.isLocked) return;

                // Appliquer la friction
                this.velocityPlayer.x -= this.velocityPlayer.x * 10.0 * delta;
                this.velocityPlayer.z -= this.velocityPlayer.z * 10.0 * delta;

                // D√©terminer la direction
                this.direction.z = Number(this.move.forward) - Number(this.move.backward);
                this.direction.x = Number(this.move.right) - Number(this.move.left);
                this.direction.normalize();

                // Acc√©l√©rer le joueur en fonction des touches press√©es
                if (this.move.forward || this.move.backward) this.velocityPlayer.z -= this.direction.z * 25.0 * delta;
                if (this.move.left || this.move.right) this.velocityPlayer.x -= this.direction.x * 25.0 * delta;

                // D√©placer le joueur
                this.controls.moveRight(-this.velocityPlayer.x * delta);
                this.controls.moveForward(-this.velocityPlayer.z * delta);
            }

            updateUI() {
                document.getElementById('money').innerText = this.money;
                document.getElementById('day').innerText = this.day;
                document.getElementById('boxesHandled').innerText = this.packagesHandled;
                document.getElementById('boxesTotal').innerText = this.config.game.packagesPerDay;
            }

            updatePackagesPerDay() {
                this.config.game.packagesPerDay = this.day * 10;
                this.packagesGenerated = 0;
            }

            nextDay() {
                this.day++;
                this.packagesHandled = 0;
                this.boxes = [];

                this.increaseGameDifficulty();

                this.updatePackagesPerDay();
                this.updateUI();
                this.updateForbiddenObjects();
                this.updateForbiddenPanel();
                this.showDayTransition();
            }

            increaseGameDifficulty() {
                this.config.speedFactor *= 1.1;
                this.config.game.moneyPerPackage += 5;
                this.config.game.moneyLostPerBadBox += 10;
            }

            showDayTransition() {
                const dayTransition = document.getElementById('dayTransition');
                dayTransition.innerText = `Jour ${this.day}`;
                dayTransition.style.display = 'flex';
                dayTransition.style.opacity = '0';

                // Animation d'apparition
                new TWEEN.Tween({ opacity: 0 })
                    .to({ opacity: 1 }, 1000)
                    .onUpdate(function (object) {
                        dayTransition.style.opacity = object.opacity;
                    })
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start()
                    .onComplete(() => {
                        // Maintenir l'affichage pendant 2 secondes
                        setTimeout(() => {
                            // Animation de disparition
                            new TWEEN.Tween({ opacity: 1 })
                                .to({ opacity: 0 }, 1000)
                                .onUpdate(function (object) {
                                    dayTransition.style.opacity = object.opacity;
                                })
                                .easing(TWEEN.Easing.Quadratic.In)
                                .start()
                                .onComplete(() => {
                                    dayTransition.style.display = 'none';
                                });
                        }, 2000);
                    });
            }

            showMoneyChange(amount) {
                const moneyDisplay = document.getElementById('money');
                const rect = moneyDisplay.getBoundingClientRect();

                const moneyChange = document.createElement('div');
                moneyChange.className = 'money-change';
                moneyChange.style.left = `${window.innerWidth / 2}px`;
                moneyChange.style.top = `${window.innerHeight / 2}px`;
                moneyChange.style.color = amount > 0 ? 'green' : 'red';
                moneyChange.innerText = `${amount > 0 ? '+' : '-'}${Math.abs(amount)}‚Ç¨`;
                document.body.appendChild(moneyChange);

                new TWEEN.Tween({ x: window.innerWidth / 2, y: window.innerHeight / 2, opacity: 1 })
                    .to({ x: rect.left + rect.width / 2, y: rect.top - 30, opacity: 0 }, 1000)
                    .onUpdate(function (object) {
                        moneyChange.style.left = `${object.x}px`;
                        moneyChange.style.top = `${object.y}px`;
                        moneyChange.style.opacity = object.opacity;
                    })
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start()
                    .onComplete(() => {
                        document.body.removeChild(moneyChange);
                    });
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));

                const delta = this.clock.getDelta();

                // Mise √† jour des animations TWEEN
                TWEEN.update();

                // G√©n√©ration des bo√Ætes
                const effectiveSpawnInterval = this.config.boxGenerator.baseSpawnInterval / this.config.speedFactor;

                if (this.packagesGenerated < this.config.game.packagesPerDay) {
                    this.boxGenerator.elapsedTime += delta * 1000;

                    if (this.boxGenerator.elapsedTime > effectiveSpawnInterval) {
                        this.spawnBox();
                        this.boxGenerator.elapsedTime = 0;
                    }
                }

                this.updateBoxes(delta);
                this.updatePlayer(delta);
                this.renderer.render(this.scene, this.camera);
            }
        }

        // D√©marrer le jeu lorsque la fen√™tre est charg√©e
        window.addEventListener('load', () => {
            new Game(CONFIG);
        });
    </script>
</body>
</html>
