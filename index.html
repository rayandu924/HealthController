<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title>Jeu Three.js avec Physique et Gameplay</title>
    <style>
        /* Styles de base pour le corps et les instructions */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            max-width: 300px;
            text-align: center;
            color: #ffffff;
            font-family: Arial, sans-serif;
            user-select: none;
            cursor: pointer;
            font-size: 24px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
        }

        /* Style pour l'affichage du score */
        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffffff;
            font-family: Arial, sans-serif;
            font-size: 24px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <!-- Instructions pour activer les contrôles -->
    <div id="instructions">Cliquez pour jouer</div>
    <!-- Affichage du score -->
    <div id="score">Score: 0</div>
    <!-- Charger les scripts principaux -->

    <!-- Charger Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Charger Cannon.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <!-- Charger GLTFLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <!-- Charger PointerLockControls -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

    <script>
        // Votre code JavaScript ici

        /**
         * Fonction utilitaire pour gérer les matériaux dans le monde physique.
         * Évite la duplication des matériaux en les stockant dans physicsWorld.materials.
         */
        function getOrCreateMaterial(physicsWorld, materialConfig) {
            if (!physicsWorld.materials) {
                physicsWorld.materials = {};
            }

            let material = physicsWorld.materials[materialConfig.name];
            if (!material) {
                material = new CANNON.Material(materialConfig.name);
                if (materialConfig.friction !== undefined) {
                    material.friction = materialConfig.friction;
                }
                if (materialConfig.restitution !== undefined) {
                    material.restitution = materialConfig.restitution;
                }
                physicsWorld.materials[materialConfig.name] = material;
            }
            return material;
        }

        // Classe de gestion du score
        class ScoreSystem {
            constructor(elementId) {
                this.score = 0;
                this.scoreElement = document.getElementById(elementId);
            }

            addPoints(points) {
                this.score += points;
                this.updateDisplay();
            }

            updateDisplay() {
                this.scoreElement.textContent = `Score: ${Math.floor(this.score)}`;
            }
        }

        // Classe de gestion de la scène
        class GameScene {
            constructor() {
                // Création de la scène
                this.scene = new THREE.Scene();

                // Configuration de la caméra
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 1.6, 5);

                // Configuration du rendu
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement);

                // Ajout d'une lumière directionnelle
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 10, 7.5);
                this.scene.add(directionalLight);

                // Création du monde physique
                this.physicsWorld = new CANNON.World();
                this.physicsWorld.gravity.set(0, -9.82, 0);
                this.physicsWorld.solver.iterations = 20;
                this.physicsWorld.broadphase = new CANNON.NaiveBroadphase();

                // Gestion du redimensionnement
                window.addEventListener('resize', this.onWindowResize.bind(this));

                // Création du sol
                this.createGround();
            }

            createGround() {
                // Création du matériau du sol
                const groundMaterialConfig = {
                    name: "groundMaterial",
                    friction: 0.5,
                    restitution: 0.3,
                };
                const groundMaterial = getOrCreateMaterial(this.physicsWorld, groundMaterialConfig);

                // Création du sol physique
                const groundBody = new CANNON.Body({
                    mass: 0,
                    shape: new CANNON.Plane(),
                    material: groundMaterial,
                });
                groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
                this.physicsWorld.addBody(groundBody);

                // Création du sol graphique
                const groundMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(100, 100),
                    new THREE.MeshStandardMaterial({ color: 0x808080 })
                );
                groundMesh.rotation.x = -Math.PI / 2;
                this.scene.add(groundMesh);
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Classe des contrôles du joueur
        class PlayerControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.controls = new THREE.PointerLockControls(this.camera, this.domElement);
                this.velocity = new THREE.Vector3();
                this.direction = new THREE.Vector3();
                this.moveSpeed = 5;
                this.controlsState = {
                    moveForward: false,
                    moveBackward: false,
                    moveLeft: false,
                    moveRight: false,
                };

                this.instructions = document.getElementById('instructions');

                this.setupEventListeners();
            }

            setupEventListeners() {
                if (this.instructions) {
                    this.instructions.addEventListener('click', () => {
                        this.controls.lock();
                    });

                    this.controls.addEventListener('lock', () => {
                        this.instructions.style.display = 'none';
                    });

                    this.controls.addEventListener('unlock', () => {
                        this.instructions.style.display = 'block';
                    });
                }

                document.addEventListener('keydown', this.handleKeyDown.bind(this));
                document.addEventListener('keyup', this.handleKeyUp.bind(this));
            }

            handleKeyDown(event) {
                switch (event.code) {
                    case 'KeyZ':
                        this.controlsState.moveForward = true;
                        break;
                    case 'KeyS':
                        this.controlsState.moveBackward = true;
                        break;
                    case 'KeyQ':
                        this.controlsState.moveLeft = true;
                        break;
                    case 'KeyD':
                        this.controlsState.moveRight = true;
                        break;
                }
            }

            handleKeyUp(event) {
                switch (event.code) {
                    case 'KeyZ':
                        this.controlsState.moveForward = false;
                        break;
                    case 'KeyS':
                        this.controlsState.moveBackward = false;
                        break;
                    case 'KeyQ':
                        this.controlsState.moveLeft = false;
                        break;
                    case 'KeyD':
                        this.controlsState.moveRight = false;
                        break;
                }
            }

            update(delta) {
                if (this.controls.isLocked) {
                    this.velocity.set(0, 0, 0);
                    if (this.controlsState.moveForward) this.velocity.z -= this.moveSpeed * delta;
                    if (this.controlsState.moveBackward) this.velocity.z += this.moveSpeed * delta;
                    if (this.controlsState.moveLeft) this.velocity.x -= this.moveSpeed * delta;
                    if (this.controlsState.moveRight) this.velocity.x += this.moveSpeed * delta;

                    this.controls.moveRight(this.velocity.x);
                    this.controls.moveForward(this.velocity.z);
                }
            }
        }

        // Classe de gestion des ressources
        class LoaderManager {
            constructor() {
                this.loaderGLTF = new THREE.GLTFLoader();
                this.models = {};
                this.objectsConfig = null;
                this.loadedModelsJSON = {};
            }

            async loadAllResources() {
                await Promise.all([
                    this.loadModels(),
                    this.loadObjectsConfig('configs/objectsConfig.json'),
                ]);
                await this.preloadModelsFromJSON();
            }

            async loadModels() {
                const modelPaths = {
                    'allowed': 'models/allowed/burger.glb',
                    'forbidden': 'models/forbidden/burger.glb',
                    'plateau': 'models/plateau.glb',
                    'poubelle': 'models/poubelle.glb',
                    // Ajoutez d'autres modèles si nécessaire
                };

                const promises = Object.keys(modelPaths).map(async key => {
                    try {
                        const gltf = await this.loaderGLTF.loadAsync(modelPaths[key]);
                        this.models[key] = gltf.scene;
                        console.log(`Modèle ${key} chargé.`);
                    } catch (error) {
                        console.error(`Erreur lors du chargement du modèle ${modelPaths[key]}:`, error);
                    }
                });

                await Promise.all(promises);
            }

            async loadObjectsConfig(url) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`Erreur de chargement du JSON: ${response.statusText}`);
                    }
                    this.objectsConfig = await response.json();
                    console.log('Configuration des objets chargée:', this.objectsConfig);
                } catch (error) {
                    console.error(error);
                    this.objectsConfig = null;
                }
            }

            async preloadModelsFromJSON() {
                if (!this.objectsConfig || !this.objectsConfig.objects.length) {
                    console.warn('Aucune configuration d\'objets disponible pour le préchargement.');
                    return;
                }

                const promises = this.objectsConfig.objects.map(async objConfig => {
                    try {
                        const gltf = await this.loaderGLTF.loadAsync(objConfig.model);
                        this.loadedModelsJSON[objConfig.id] = gltf.scene;
                        console.log(`Modèle ${objConfig.id} chargé.`);
                    } catch (error) {
                        console.error(`Erreur lors du chargement du modèle ${objConfig.model}:`, error);
                    }
                });

                await Promise.all(promises);
            }
        }

        // Classe pour les objets de la carte
        class MapObject {
            constructor(physicsWorld, scene, config, models) {
                this.physicsWorld = physicsWorld;
                this.scene = scene;
                this.config = config;
                this.models = models;

                this.createObject();
            }

            createObject() {
                let mesh;

                if (this.config.model) {
                    // Vérifie si le modèle est chargé
                    if (this.models[this.config.model]) {
                        // Utilise le modèle GLB
                        mesh = this.models[this.config.model].clone();
                    } else {
                        console.warn(`Le modèle "${this.config.model}" n'est pas chargé.`);
                        return; // Arrête la création de l'objet
                    }
                } else {
                    // Crée une forme géométrique par défaut si aucun modèle n'est défini
                    const geometry = new THREE.BoxGeometry(
                        this.config.size?.x || 1,
                        this.config.size?.y || 1,
                        this.config.size?.z || 1
                    );
                    const material = new THREE.MeshStandardMaterial({ color: this.config.color || 0xffffff });
                    mesh = new THREE.Mesh(geometry, material);
                }

                mesh.position.copy(this.config.position || new THREE.Vector3());
                this.scene.add(mesh);

                // Gestion du matériau
                let material = null;
                if (this.config.material) {
                    material = getOrCreateMaterial(this.physicsWorld, this.config.material);
                }

                // Création du corps physique
                const shape = new CANNON.Box(new CANNON.Vec3(
                    (this.config.size?.x || 1) / 2,
                    (this.config.size?.y || 1) / 2,
                    (this.config.size?.z || 1) / 2
                ));

                const body = new CANNON.Body({
                    mass: this.config.mass || 0,
                    shape,
                    position: new CANNON.Vec3(
                        this.config.position?.x || 0,
                        this.config.position?.y || 0,
                        this.config.position?.z || 0
                    ),
                    material: material,
                });

                // Gestion des matériaux de contact
                if (this.config.contactMaterials) {
                    this.config.contactMaterials.forEach(contactMaterialConfig => {
                        const materialA = material;
                        const materialB = getOrCreateMaterial(this.physicsWorld, contactMaterialConfig.with);
                        const contactMaterial = new CANNON.ContactMaterial(materialA, materialB, {
                            friction: contactMaterialConfig.friction || 0,
                            restitution: contactMaterialConfig.restitution || 0,
                        });
                        this.physicsWorld.addContactMaterial(contactMaterial);
                    });
                }

                this.physicsWorld.addBody(body);
                mesh.userData.body = body;
                this.mesh = mesh;
                this.body = body;
            }

            update() {
                // Si l'objet est dynamique, mettre à jour sa position
                if (this.body.mass > 0) {
                    this.mesh.position.copy(this.body.position);
                    this.mesh.quaternion.copy(this.body.quaternion);
                }
            }
        }

        // Classe du tapis roulant
        class ConveyorBelt {
            constructor(physicsWorld, scene, { size, position, velocity, material = new THREE.MeshStandardMaterial({ color: 0x555555 }) }) {
                this.physicsWorld = physicsWorld;
                this.scene = scene;
                this.size = size;
                this.velocity = velocity.clone();

                // Gestion du matériau du tapis roulant
                const conveyorMaterialConfig = {
                    name: "conveyorMaterial",
                    friction: 0,
                    restitution: 0,
                };
                const conveyorMaterial = getOrCreateMaterial(this.physicsWorld, conveyorMaterialConfig);

                // Création du mesh graphique
                this.mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(this.size.x, this.size.y, this.size.z),
                    material
                );
                this.mesh.position.copy(position);
                this.scene.add(this.mesh);

                // Création du corps physique avec le matériau
                this.body = new CANNON.Body({
                    mass: 0,
                    shape: new CANNON.Box(new CANNON.Vec3(this.size.x / 2, this.size.y / 2, this.size.z / 2)),
                    position: new CANNON.Vec3(position.x, position.y, position.z),
                    material: conveyorMaterial,
                });
                this.physicsWorld.addBody(this.body);

                // Configurer le matériau de contact entre le tapis roulant et les plateaux
                const plateauMaterial = getOrCreateMaterial(this.physicsWorld, { name: "plateauMaterial" });
                const contactMaterial = new CANNON.ContactMaterial(conveyorMaterial, plateauMaterial, {
                    friction: 0, // Sans friction
                    restitution: 0,
                });
                this.physicsWorld.addContactMaterial(contactMaterial);
            }

            setVelocity(newVelocity) {
                this.velocity.copy(newVelocity);
            }

            applyEffect() {
                this.physicsWorld.bodies.forEach(body => {
                    if (body.mass > 0) {
                        // Vérifier si le body est en contact avec le tapis roulant
                        const contactPairs = this.physicsWorld.contacts.filter(contact => {
                            return (contact.bi === this.body || contact.bj === this.body) &&
                                (contact.bi === body || contact.bj === body);
                        });

                        if (contactPairs.length > 0) {
                            // Appliquer une force pour simuler le mouvement du tapis roulant
                            const force = new CANNON.Vec3(
                                this.velocity.x * body.mass * 10,
                                this.velocity.y * body.mass * 10,
                                this.velocity.z * body.mass * 10
                            );
                            body.applyForce(force, body.position);
                        }
                    }
                });
            }
        }


        // Classe pour les objets interactifs (plateaux)
        class InteractiveObject {
            constructor(physicsWorld, scene, model, position, objectsConfig, loadedModelsJSON) {
                this.physicsWorld = physicsWorld;
                this.scene = scene;
                this.mesh = model.clone();
                this.mesh.position.copy(position);
                this.scene.add(this.mesh);

                // Indiquer que c'est un plateau
                this.mesh.userData.isPlateau = true;

                // Création du corps physique
                const bbox = new THREE.Box3().setFromObject(this.mesh);
                const size = new THREE.Vector3();
                bbox.getSize(size);
                const shape = new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));

                // Gestion du matériau du plateau
                const plateauMaterialConfig = {
                    name: "plateauMaterial",
                    friction: 0, // Sans friction avec le tapis roulant
                    restitution: 0,
                };
                const plateauMaterial = getOrCreateMaterial(this.physicsWorld, plateauMaterialConfig);

                this.body = new CANNON.Body({
                    mass: 1,
                    shape,
                    position: new CANNON.Vec3(position.x, position.y, position.z),
                    linearDamping: 0.1,
                    angularDamping: 0.9, // Désactiver la rotation
                    material: plateauMaterial,
                });

                this.physicsWorld.addBody(this.body);
                this.mesh.userData.body = this.body;
                this.mesh.userData.interactive = true; // Ajouté pour le grab

                // Marquer si l'objet est interdit
                this.mesh.userData.hasForbidden = false;

                // Ajouter des objets sur le plateau
                this.addObjectsToPlateau(objectsConfig, loadedModelsJSON);
            }

            addObjectsToPlateau(objectsConfig, loadedModelsJSON) {
                if (!objectsConfig || !objectsConfig.objects.length) {
                    console.warn('Aucune configuration d\'objets disponible.');
                    return;
                }

                const basePositions = [
                    new THREE.Vector3(0.3, 0.1, 0.2),
                    new THREE.Vector3(0, 0.1, 0.2),
                    new THREE.Vector3(-0.3, 0.1, 0.2),
                    new THREE.Vector3(0.3, 0.1, -0.2),
                    new THREE.Vector3(0, 0.1, -0.2),
                    new THREE.Vector3(-0.3, 0.1, -0.2),
                ];

                const selectedObjects = objectsConfig.objects.sort(() => Math.random() - 0.5).slice(0, 6);

                selectedObjects.forEach((objConfig, index) => {
                    const preloadedModel = loadedModelsJSON[objConfig.id];
                    if (!preloadedModel) {
                        console.warn(`Modèle préchargé manquant pour l'objet ID: ${objConfig.id}`);
                        return;
                    }

                    const clonedModel = preloadedModel.clone();

                    const positionOffset = new THREE.Vector3(
                        objConfig.position?.x || 0,
                        objConfig.position?.y || 0,
                        objConfig.position?.z || 0
                    );

                    const finalPosition = basePositions[index].clone().add(positionOffset);
                    clonedModel.position.copy(finalPosition);

                    clonedModel.rotation.set(
                        THREE.MathUtils.degToRad(objConfig.rotation?.x || 0),
                        THREE.MathUtils.degToRad(objConfig.rotation?.y || 0),
                        THREE.MathUtils.degToRad(objConfig.rotation?.z || 0)
                    );

                    clonedModel.scale.set(
                        objConfig.scale?.x || 1,
                        objConfig.scale?.y || 1,
                        objConfig.scale?.z || 1
                    );

                    this.mesh.add(clonedModel);

                    // Marquer l'objet comme interdit si nécessaire
                    if (objConfig.model.includes('forbidden')) {
                        this.mesh.userData.hasForbidden = true;
                        clonedModel.traverse(child => {
                            if (child.isMesh) {
                                child.parent.userData.hasForbidden = true;
                            }
                        });
                    }
                });
            }

            update() {
                this.mesh.position.copy(this.body.position);
                this.mesh.quaternion.copy(this.body.quaternion);
            }
        }

        // Classe de la poubelle
        class GarbageBin {
            constructor(physicsWorld, scene, model, scoreSystem) {
                this.physicsWorld = physicsWorld;
                this.scene = scene;
                this.scoreSystem = scoreSystem;
                this.mesh = model.clone();
                this.mesh.position.set(0, 1, 10);
                this.scene.add(this.mesh);

                const bbox = new THREE.Box3().setFromObject(this.mesh);
                const size = new THREE.Vector3();
                bbox.getSize(size);
                const shape = new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));

                // Création du matériau de la poubelle
                const garbageMaterialConfig = {
                    name: "garbageMaterial",
                    friction: 0.5,
                    restitution: 0.3,
                };
                const garbageMaterial = getOrCreateMaterial(this.physicsWorld, garbageMaterialConfig);

                this.body = new CANNON.Body({
                    mass: 0,
                    shape,
                    position: new CANNON.Vec3(0, 1, 10),
                    material: garbageMaterial,
                });
                this.physicsWorld.addBody(this.body);

                // Écouteur d'événement de collision
                this.body.addEventListener('collide', this.handleCollision.bind(this));
            }

            handleCollision(event) {
                const collidedBody = event.body;

                // Vérifiez si le corps collisionné est un plateau
                if (collidedBody && collidedBody.mesh && collidedBody.mesh.userData.isPlateau) {
                    // Supprimer l'objet de la scène et du monde physique
                    this.scene.remove(collidedBody.mesh);
                    this.physicsWorld.removeBody(collidedBody);

                    // Mettre à jour le score
                    this.scoreSystem.addPoints(10);
                    console.log('Plateau jeté dans la poubelle ! Score +10.');
                }
            }
        }

        // Initialisation de la scène
        const gameScene = new GameScene();

        // Gestion du score
        const scoreSystem = new ScoreSystem('score');

        // Gestion des ressources
        const loaderManager = new LoaderManager();

        // Variables pour le grab
        let grabbedBody = null;
        let grabConstraint = null;
        let grabHoldBody = null; // Corps fixe représentant le point de grab

        // Liste des objets interactifs
        const interactiveObjects = [];
        const interactiveMeshes = []; // Ajouté pour le grab
        const interactiveBodies = []; // Ajouté pour le grab

        // Fonction pour attraper un objet
        function grabObject(body) {
            if (grabConstraint) {
                releaseObject(); // Libérer tout objet déjà attrapé
            }

            grabbedBody = body;

            // Définir le point de maintien devant la caméra
            const cameraDirection = new THREE.Vector3();
            gameScene.camera.getWorldDirection(cameraDirection);
            const holdPoint = new CANNON.Vec3(
                gameScene.camera.position.x + cameraDirection.x * 1.5,
                gameScene.camera.position.y + cameraDirection.y * 1.5,
                gameScene.camera.position.z + cameraDirection.z * 1.5
            );

            // Création d'un corps fixe pour représenter le point de maintien
            grabHoldBody = new CANNON.Body({
                mass: 0, // Corps statique
                position: holdPoint,
                shape: new CANNON.Sphere(0.1), // Corps point avec un petit rayon
            });
            gameScene.physicsWorld.addBody(grabHoldBody);

            // Création de la contrainte entre l'objet attrapé et le point de maintien
            grabConstraint = new CANNON.PointToPointConstraint(
                grabbedBody,
                new CANNON.Vec3(0, 0, 0), // Pivot local sur l'objet attrapé
                grabHoldBody,
                new CANNON.Vec3(0, 0, 0), // Pivot local sur le point de maintien
                {
                    maxForce: 1000,
                }
            );
            gameScene.physicsWorld.addConstraint(grabConstraint);

            // Bloquer la rotation de l’objet en fixant sa vitesse angulaire à zéro
            grabbedBody.angularVelocity.set(0, 0, 0);
            grabbedBody.angularDamping = 1; // Réduire les rotations
        }

        // Fonction pour relâcher un objet
        function releaseObject() {
            if (grabConstraint) {
                gameScene.physicsWorld.removeConstraint(grabConstraint);
                grabConstraint = null;
            }
            if (grabHoldBody) {
                gameScene.physicsWorld.removeBody(grabHoldBody);
                grabHoldBody = null;
            }

            // Rétablir l'amortissement angulaire à la valeur par défaut
            if (grabbedBody) {
                grabbedBody.angularDamping = 0.1; // Ou la valeur par défaut utilisée dans votre jeu
            }

            grabbedBody = null;
        }

        // Mettre à jour la position du point de maintien
        function updateGrabHoldPosition() {
            if (grabHoldBody) {
                const cameraDirection = new THREE.Vector3();
                gameScene.camera.getWorldDirection(cameraDirection);
                const newHoldPoint = new CANNON.Vec3(
                    gameScene.camera.position.x + cameraDirection.x * 1.5,
                    gameScene.camera.position.y + cameraDirection.y * 1.5,
                    gameScene.camera.position.z + cameraDirection.z * 1.5
                );
                grabHoldBody.position.copy(newHoldPoint);
            }
        }

        // Événements de la souris
        window.addEventListener('mousedown', () => {
            if (grabbedBody) return; // Ne rien faire si un objet est déjà attrapé

            const raycaster = new THREE.Raycaster();
            const center = new THREE.Vector2(0, 0); // Centre de l'écran
            raycaster.setFromCamera(center, gameScene.camera);

            // Intersections avec les objets interactifs
            const intersects = raycaster.intersectObjects(interactiveMeshes, true); // Inclure les descendants

            if (intersects.length > 0) {
                const intersectedMesh = intersects[0].object;
                let bodyToGrab = null;

                // Trouver le mesh parent s'il existe
                let parentMesh = intersectedMesh;
                while (parentMesh && !interactiveMeshes.includes(parentMesh)) {
                    parentMesh = parentMesh.parent;
                }

                if (parentMesh) {
                    const index = interactiveMeshes.indexOf(parentMesh);
                    bodyToGrab = interactiveBodies[index];
                }

                if (bodyToGrab) {
                    grabObject(bodyToGrab);
                }
            }
        });

        window.addEventListener('mouseup', () => {
            releaseObject();
        });

        // Chargement des ressources
        loaderManager.loadAllResources().then(() => {
            // Création des contrôles du joueur
            const playerControls = new PlayerControls(gameScene.camera, gameScene.renderer.domElement);

            // Création du tapis roulant
            const conveyorBelt = new ConveyorBelt(gameScene.physicsWorld, gameScene.scene, {
                size: { x: 20, y: 0.1, z: 3 },
                position: new THREE.Vector3(0, 0.05, -5),
                velocity: new CANNON.Vec3(0.01, 0, 0), // Vitesse initiale
            });

            // Vous pouvez changer la vitesse du tapis roulant
            // conveyorBelt.setVelocity(new CANNON.Vec3(10, 0, 0));

            // Création de la poubelle
            const garbageBin = new GarbageBin(gameScene.physicsWorld, gameScene.scene, loaderManager.models['poubelle'], scoreSystem);

            // Génération des objets de la carte à partir de la configuration
            const mapObjectsConfig = [
                {
                    size: { x: 1, y: 1, z: 1 },
                    position: new THREE.Vector3(10, 0.5, -5),
                    color: 0x00ff00,
                    mass: 0,
                    material: {
                        name: "groundMaterial",
                        friction: 0.4,
                        restitution: 0.3,
                    },
                    contactMaterials: [
                        {
                            with: {
                                name: "plateauMaterial",
                            },
                            friction: 0, // Sans friction avec les plateaux
                            restitution: 0.2,
                        },
                    ],
                },
                // Ajoutez d'autres objets ici
            ];

            mapObjectsConfig.forEach(config => {
                const mapObject = new MapObject(gameScene.physicsWorld, gameScene.scene, config, loaderManager.models);
            });

            // Génération périodique des plateaux
            setInterval(() => {
                const interactiveObject = new InteractiveObject(
                    gameScene.physicsWorld,
                    gameScene.scene,
                    loaderManager.models['plateau'],
                    new THREE.Vector3(-9, 1, -5),
                    loaderManager.objectsConfig,
                    loaderManager.loadedModelsJSON
                );
                interactiveObjects.push(interactiveObject);
                interactiveMeshes.push(interactiveObject.mesh); // Ajouté pour le grab
                interactiveBodies.push(interactiveObject.body); // Ajouté pour le grab
            }, 5000);

            // Boucle d'animation
            const clock = new THREE.Clock();
            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();

                // Mise à jour des contrôles
                playerControls.update(delta);

                // Mise à jour de la physique
                gameScene.physicsWorld.step(1 / 60, delta);

                // Mise à jour des objets interactifs
                interactiveObjects.forEach(obj => obj.update());

                // Appliquer l'effet du tapis roulant
                conveyorBelt.applyEffect();

                // Mise à jour de la position de l'objet attrapé
                updateGrabHoldPosition(); // Ajouté

                // Rendu de la scène
                gameScene.renderer.render(gameScene.scene, gameScene.camera);
            }

            animate();
        });
    </script>
</body>

</html>
