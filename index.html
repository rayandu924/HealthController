<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title>Jeu 3D avec Three.js et Cannon.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 600px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            user-select: none;
            cursor: pointer;
            z-index: 1500;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .instruction-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 5px;
        }

        .instruction-text {
            font-size: 1.2rem;
        }

        .instruction-icon {
            font-size: 2rem;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #start-button {
            padding: 10px 20px;
            font-size: 1.5rem;
            border: none;
            border-radius: 5px;
            background-color: #28a745;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #start-button:hover {
            background-color: #218838;
        }

        .game-description {
            font-size: 1rem;
            padding: 0 20px;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            margin-left: -5px;
            margin-top: -5px;
            background-color: white;
            border: 2px solid black;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
        }

        .slider-container {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            width: 400px;
            z-index: 1000;
        }

        .emoji {
            font-size: 3rem;
            margin: 0 15px;
            transition: font-size 0.3s, transform 0.3s;
        }

        .slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 15px;
            border-radius: 7.5px;
            background: linear-gradient(to right, red, green);
            outline: none;
            margin: 0;
            padding: 0;
            transition: background 0.3s;
            position: relative;
            pointer-events: none;
        }

        .slider:hover {
            background: linear-gradient(to right, darkred, darkgreen);
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            background: url('textures/cursor.png') no-repeat center;
            background-size: contain;
            cursor: pointer;
            margin-top: -50px;
            border: none;
        }

        .slider::-moz-range-thumb {
            width: 40px;
            height: 40px;
            background: url('textures/cursor.png') no-repeat center;
            background-size: contain;
            cursor: pointer;
            border: none;
            transform: translateY(-12.5px);
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
            pointer-events: all;
        }

        .slider::-moz-focus-outer {
            border: 0;
        }

        .slider:focus {
            outline: none;
        }

        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 2000;
        }

        #gameOverContent {
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .game-over-emoji {
            font-size: 5rem;
            margin-bottom: 20px;
            opacity: 0;
            transform: translateY(50px);
        }

        .game-over-message {
            font-size: 2.5rem;
            margin-bottom: 10px;
            opacity: 0;
        }

        .game-over-timer {
            font-size: 1.5rem;
            opacity: 0;
        }
    </style>
</head>

<body>
    <div id="instructions">
        <div class="instruction-item">
            <span class="instruction-text">Attraper les plateaux avec clic droit</span>
            <span class="instruction-icon">üîÑ</span>
        </div>
        <div class="instruction-item">
            <span class="instruction-text">Se d√©placer avec ZQSD</span>
            <span class="instruction-icon">üïπÔ∏è</span>
        </div>
        <p class="game-description">
            Devenez le h√©ros silencieux d‚Äôun lyc√©e en crise nutritionnelle. En tant que cantinier, vous vous souciez de
            la sant√© des √©l√®ves. C'est pourquoi vous n'h√©sitez pas √† jeter √† la poubelle les plateaux mauvais pour
            maintenir la bonne sant√© des √©l√®ves. Un conseil soyez rapide !
        </p>
        <button id="start-button">Cliquez pour d√©marrer</button>
    </div>
    <div id="crosshair"></div>
    <div class="slider-container">
        <span class="emoji" id="leftEmoji">üòà</span>
        <input type="range" min="0" max="100" value="50" class="slider" id="healthySlider" disabled>
        <span class="emoji" id="rightEmoji">üòé</span>
    </div>
    <div id="gameOverScreen" style="display: none;">
        <div id="gameOverContent">
            <span id="gameOverEmoji" class="game-over-emoji"></span>
            <h1 id="gameOverMessage" class="game-over-message"></h1>
            <p id="gameOverTimer" class="game-over-timer"></p>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        let previousValue = 0;

        function updateHealthySlider(count) {
            const slider = document.getElementById('healthySlider');
            slider.value = count;

            const leftEmoji = document.getElementById('leftEmoji');
            const rightEmoji = document.getElementById('rightEmoji');

            const leftSize = 7 - (count / 100) * 5;
            const rightSize = 4 - (count / 100) * 3;

            gsap.to(leftEmoji, { duration: 0.3, fontSize: `${leftSize}rem` });
            gsap.to(rightEmoji, { duration: 0.3, fontSize: `${rightSize}rem` });

            if (count > previousValue) {
                gsap.fromTo(rightEmoji, { scale: 1 }, { scale: 2, duration: 0.2, yoyo: true, repeat: 1 });
            } else if (count < previousValue) {
                gsap.fromTo(leftEmoji, { scale: 1 }, { scale: 2, duration: 0.2, yoyo: true, repeat: 1 });
            }
            previousValue = count;
        }

        window.updateHealthySlider = updateHealthySlider;

        const COLLISION_GROUP_PLAYER = 1 << 0;
        const COLLISION_GROUP_OBJECT = 1 << 1;

        class EventEmitter {
            constructor() {
                this.events = {};
            }

            on(event, listener) {
                if (!this.events[event]) {
                    this.events[event] = [];
                }
                this.events[event].push(listener);
            }

            emit(event, data) {
                if (this.events[event]) {
                    this.events[event].forEach(listener => listener(data));
                }
            }
        }

        class SceneManager {
            constructor() {
                this.scene = new THREE.Scene();
                const ambientLight = new THREE.AmbientLight(0xe0e0e0);
                this.scene.add(ambientLight);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement);
            }

            render(camera) {
                this.renderer.render(this.scene, camera);
            }
        }

        class PhysicsManager {
            constructor() {
                this.world = new CANNON.World();
                this.world.gravity.set(0, -9.82, 0);
                this.fixedTimeStep = 1 / 60;
                this.maxSubSteps = 3;
            }

            step() {
                this.world.step(this.fixedTimeStep, undefined, this.maxSubSteps);
            }
        }

        class InputManager {
            constructor() {
                this.keys = {};
                this.listeners = {};
                this.initControls();
            }

            initControls() {
                document.addEventListener('keydown', (e) => this.onKeyChange(e, true));
                document.addEventListener('keyup', (e) => this.onKeyChange(e, false));
            }

            onKeyChange(event, isPressed) {
                const key = event.key.toLowerCase();
                this.keys[key] = isPressed;
                if (this.listeners[key]) {
                    this.listeners[key].forEach(callback => callback(isPressed));
                }
            }

            bindKey(key, callback) {
                key = key.toLowerCase();
                if (!this.listeners[key]) {
                    this.listeners[key] = [];
                }
                this.listeners[key].push(callback);
            }

            isKeyPressed(key) {
                return !!this.keys[key.toLowerCase()];
            }
        }

        class GameObject {
            constructor(options) {
                this.scene = options.scene;
                this.world = options.world;
                this.game = options.game;

                const defaultTransform = {
                    position: { x: 0, y: 0, z: 0 },
                    rotation: { x: 0, y: 0, z: 0 },
                    size: { x: 1, y: 1, z: 1 }
                };
                const defaultAppearance = {
                    color: 0xffffff,
                    opacity: 1,
                    texture: null,
                    repeating: false,
                    repeatDimensions: { x: 1, y: 1 },
                    shapeType: 'box'
                };
                const defaultModel = { path: null };
                const defaultIsDynamic = false;

                this.transform = Object.assign({}, defaultTransform, options.transform);
                this.transform.position = Object.assign({}, defaultTransform.position, options.transform?.position);
                this.transform.rotation = Object.assign({}, defaultTransform.rotation, options.transform?.rotation);
                this.transform.size = Object.assign({}, defaultTransform.size, options.transform?.size);

                this.appearance = Object.assign({}, defaultAppearance, options.appearance);
                this.model = Object.assign({}, defaultModel, options.model);
                this.isDynamic = options.isDynamic ?? defaultIsDynamic;

                this.physics = options.physics ? Object.assign({}, options.physics) : null;
                if (this.physics) {
                    this.body = new CANNON.Body({
                        mass: this.physics.mass,
                        position: new CANNON.Vec3(
                            this.transform.position.x,
                            this.transform.position.y,
                            this.transform.position.z
                        ),
                        material: new CANNON.Material({ friction: this.physics.friction }),
                        quaternion: new CANNON.Quaternion().setFromEuler(
                            this.transform.rotation.x,
                            this.transform.rotation.y,
                            this.transform.rotation.z,
                            'XYZ'
                        ),
                        collisionFilterGroup: COLLISION_GROUP_OBJECT,
                        collisionFilterMask: COLLISION_GROUP_PLAYER | COLLISION_GROUP_OBJECT
                    });

                    if (options.collider) {
                        this.collider = Object.assign({}, options.collider);
                        this.setCollider();
                    }

                    this.world.addBody(this.body);
                } else {
                    this.body = null;
                }

                this.initVisual();

                if (this.isDynamic) {
                    this.game.dynamicObjects.push(this);
                }

                this.isGrabbed = false;
            }

            setCollider() {
                const { type, size } = this.collider;
                let shape;
                switch (type) {
                    case 'sphere':
                        shape = new CANNON.Sphere(size.x / 2);
                        break;
                    case 'cylinder':
                        shape = new CANNON.Cylinder(size.x / 2, size.x / 2, size.y, 12);
                        break;
                    case 'box':
                    default:
                        shape = new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));
                }
                this.body.addShape(shape);
            }

            initVisual() {
                const { color, opacity, texture, repeating, repeatDimensions, shapeType } = this.appearance;
                const { size } = this.transform;

                const materialOptions = {
                    color: color,
                    transparent: opacity < 1,
                    opacity: opacity
                };

                if (texture) {
                    const textureLoader = new THREE.TextureLoader();
                    const loadedTexture = textureLoader.load(texture);
                    if (repeating) {
                        loadedTexture.wrapS = loadedTexture.wrapT = THREE.RepeatWrapping;
                        loadedTexture.repeat.set(repeatDimensions.x, repeatDimensions.y);
                    }
                    materialOptions.map = loadedTexture;
                }

                const material = new THREE.MeshStandardMaterial(materialOptions);

                if (this.model.path) {
                    const loader = new THREE.GLTFLoader();
                    loader.load(this.model.path, (gltf) => {
                        this.mesh = gltf.scene;
                        this.mesh.userData.gameObject = this;
                        this.applyTransformations();
                        this.scene.add(this.mesh);

                        if (this.body) {
                            this.mesh.traverse((child) => {
                                if (child.isMesh) {
                                    child.userData.body = this.body;
                                }
                            });
                        }

                        if (this.body) {
                            this.addColliderHelper();
                        }
                    });
                } else {
                    this.createDefaultMesh(shapeType, material, size);
                }
            }

            createDefaultMesh(shapeType, material, size) {
                switch (shapeType) {
                    case 'sphere':
                        this.mesh = new THREE.Mesh(new THREE.SphereGeometry(size.x / 2, 32, 32), material);
                        break;
                    case 'cylinder':
                        this.mesh = new THREE.Mesh(new THREE.CylinderGeometry(size.x / 2, size.x / 2, size.y, 12), material);
                        break;
                    case 'box':
                    default:
                        this.mesh = new THREE.Mesh(new THREE.BoxGeometry(size.x, size.y, size.z), material);
                }
                this.mesh.userData.gameObject = this;
                this.applyTransformations();
                this.scene.add(this.mesh);

                if (this.body) {
                    this.mesh.userData.body = this.body;
                    this.addColliderHelper();
                }
            }

            applyTransformations() {
                if (this.mesh) {
                    this.mesh.position.set(
                        this.transform.position.x,
                        this.transform.position.y,
                        this.transform.position.z
                    );
                    this.mesh.rotation.set(
                        this.transform.rotation.x,
                        this.transform.rotation.y,
                        this.transform.rotation.z
                    );
                    if (this.body) {
                        this.mesh.position.copy(this.body.position);
                        this.mesh.quaternion.copy(this.body.quaternion);
                    }
                }
            }

            addColliderHelper() {
                if (!this.game.debug) return;
                if (!this.body || !this.body.shapes[0]) return;

                let geometry;
                const shape = this.body.shapes[0];
                switch (shape.type) {
                    case CANNON.Shape.types.BOX:
                        const halfExtents = shape.halfExtents;
                        geometry = new THREE.BoxGeometry(
                            halfExtents.x * 2,
                            halfExtents.y * 2,
                            halfExtents.z * 2
                        );
                        break;
                    case CANNON.Shape.types.SPHERE:
                        const radius = shape.radius;
                        geometry = new THREE.SphereGeometry(radius, 16, 16);
                        break;
                    case CANNON.Shape.types.CYLINDER:
                        const radiusTop = shape.radiusTop;
                        const radiusBottom = shape.radiusBottom;
                        const height = shape.height;
                        geometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, 16);
                        break;
                    default:
                        console.warn('Type de forme non reconnu pour la visualisation du collider.');
                        return;
                }
                const material = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const helper = new THREE.Mesh(geometry, material);
                helper.name = 'ColliderHelper';
                this.scene.add(helper);

                helper.position.copy(this.body.position);
                helper.quaternion.copy(this.body.quaternion);

                if (this.body.mass > 0) {
                    this.updateColliderHelper = () => {
                        helper.position.copy(this.body.position);
                        helper.quaternion.copy(this.body.quaternion);
                    };
                }
            }

            grab() {
                this.isGrabbed = true;
            }

            ungrab() {
                this.isGrabbed = false;
            }

            update() {
                if (this.isGrabbed) return;
                if (this.body && this.mesh) {
                    this.mesh.position.copy(this.body.position);
                    this.mesh.quaternion.copy(this.body.quaternion);
                    if (this.updateColliderHelper) {
                        this.updateColliderHelper();
                    }
                }
            }
        }

        class Tray extends GameObject {
            constructor(options) {
                super(options);
                this.type = 'tray';
                this.healthyCount = 0;
                this.unhealthyCount = 0;

                this.healthyFoodModels = [
                    'models/foods/apple.glb',
                    'models/foods/pineapple.glb',
                    'models/foods/banana.glb',
                    'models/foods/strawberries.glb',
                    'models/foods/tomato.glb',
                    'models/foods/water.glb',
                    'models/foods/egg.glb',
                    'models/foods/chicken.glb'
                ];

                this.unhealthyFoodModels = [
                    'models/foods/burger.glb',
                    'models/foods/hotdog.glb',
                    'models/foods/chips.glb',
                    'models/foods/pizza.glb',
                    'models/foods/donut.glb',
                    'models/foods/icecream.glb',
                    'models/foods/chocolate.glb',
                    'models/foods/cupcake.glb',
                    'models/foods/soda.glb'
                ];

                this.initFood();
            }

            initFood() {
                const positions = [
                    { x: -0.5, y: 0.02, z: -0.3 },
                    { x: 0, y: 0.02, z: -0.3 },
                    { x: 0.5, y: 0.02, z: -0.3 },
                    { x: -0.5, y: 0.02, z: 0.3 },
                    { x: 0, y: 0.02, z: 0.3 },
                    { x: 0.5, y: 0.02, z: 0.3 }
                ];

                const loader = new THREE.GLTFLoader();
                const count = Math.floor(Math.random() * 6) + 1;
                const shuffled = positions.sort(() => 0.5 - Math.random()).slice(0, count);

                const randomValue = Math.random();
                let isHealthyTray = randomValue < 1 - this.game.difficulty;

                if (isHealthyTray) {
                    this.healthyCount += count;
                } else {
                    this.healthyCount -= count;
                }

                const selectedFoodModels = isHealthyTray ? this.healthyFoodModels : this.unhealthyFoodModels;

                shuffled.forEach(position => {
                    const modelPath = selectedFoodModels[Math.floor(Math.random() * selectedFoodModels.length)];
                    loader.load(modelPath, gltf => {
                        const food = gltf.scene;
                        food.position.set(position.x, position.y, position.z);
                        this.mesh.add(food);
                    });
                });
            }
        }

        class TrayReceptor extends GameObject {
            constructor(options) {
                super(options);
            }

            update() {
                this.game.dynamicObjects.forEach(obj => {
                    const body = obj.body;
                    if (this.isInContact(body)) {
                        if (obj.type === 'tray') {
                            this.game.player.healthyCount += obj.healthyCount;
                            window.updateHealthySlider(this.game.player.healthyCount);
                            if (this.game.player.healthyCount <= 0) {
                                this.game.gameOverFunction(false);
                            } else if (this.game.player.healthyCount >= 100) {
                                this.game.gameOverFunction(true);
                            }
                            this.scene.remove(obj.mesh);
                            this.world.removeBody(obj.body);
                        }
                    }
                });
                super.update();
            }

            isInContact(body) {
                return this.world.contacts.some(contact => (
                    (contact.bi === this.body && contact.bj === body) ||
                    (contact.bj === this.body && contact.bi === body)
                ));
            }
        }

        class Bin extends GameObject {
            constructor(options) {
                super(options);
                this.lid = this.game.BinLid;
                this.isAnimating = false;
                this.targetRotation = 0;
                this.openRotation = -Math.PI / 2;
                this.closeRotation = 0;
                this.closeLidTimer = null;
            }

            update() {
                this.game.dynamicObjects.forEach(obj => {
                    const body = obj.body;
                    if (this.isInContact(body) && obj.type === 'tray') {
                        this.scene.remove(obj.mesh);
                        this.world.removeBody(obj.body);
                        const audio = new Audio('sounds/trash.wav');
                        audio.volume = 0.3;
                        audio.play();
                        this.toggleLid();
                    }
                });

                if (this.isAnimating) {
                    this.animateLid();
                }

                super.update();
            }

            toggleLid() {
                if (this.isAnimating) return;
                this.targetRotation = (this.lid.transform.rotation.x === this.closeRotation) ? this.openRotation : this.closeRotation;
                this.isAnimating = true;

                if (this.targetRotation === this.openRotation) {
                    if (this.closeLidTimer) {
                        clearTimeout(this.closeLidTimer);
                    }
                    this.closeLidTimer = setTimeout(() => {
                        this.toggleLid();
                    }, 500);
                } else {
                    if (this.closeLidTimer) {
                        clearTimeout(this.closeLidTimer);
                        this.closeLidTimer = null;
                    }
                }
            }

            animateLid() {
                this.lid.transform.rotation.x += (this.targetRotation - this.lid.transform.rotation.x) * 0.1;
                this.lid.applyTransformations();

                if (Math.abs(this.targetRotation - this.lid.transform.rotation.x) < 0.01) {
                    this.lid.transform.rotation.x = this.targetRotation;
                    this.lid.applyTransformations();
                    this.isAnimating = false;

                    if (this.targetRotation === this.closeRotation && this.closeLidTimer) {
                        clearTimeout(this.closeLidTimer);
                        this.closeLidTimer = null;
                    }
                }
            }

            isInContact(body) {
                return this.world.contacts.some(contact => (
                    (contact.bi === this.body && contact.bj === body) ||
                    (contact.bj === this.body && contact.bi === body)
                ));
            }
        }

        class ConveyorBelt extends GameObject {
            constructor(options) {
                super(options);
                this.speed = options.speed || 0.5;
                const rotation = options.transform.rotation || new THREE.Vector3(0, 0, 0);
                const euler = new THREE.Euler(rotation.x, rotation.y, rotation.z, 'XYZ');
                this.direction = new THREE.Vector3(1, 0, 0).applyEuler(euler).normalize();
            }

            setSpeed(newSpeed) {
                this.speed = newSpeed;
            }

            update() {
                this.game.dynamicObjects.forEach(obj => {
                    const body = obj.body;
                    if (this.isInContact(body)) {
                        body.velocity.set(
                            this.direction.x * this.speed,
                            body.velocity.y,
                            this.direction.z * this.speed
                        );
                    }
                });
                super.update();
            }

            isInContact(body) {
                return this.world.contacts.some(contact => (
                    (contact.bi === this.body && contact.bj === body) ||
                    (contact.bj === this.body && contact.bi === body)
                ));
            }
        }

        class IntervalExecutor {
            constructor(callback, interval) {
                this.callback = callback;
                this.interval = interval;
                this.timerId = null;
                this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
                this.start();
                document.addEventListener('visibilitychange', this.handleVisibilityChange);
            }

            start() {
                this.stop();
                if (!document.hidden) {
                    this.timerId = setInterval(this.callback, this.interval);
                }
            }

            stop() {
                if (this.timerId !== null) {
                    clearInterval(this.timerId);
                    this.timerId = null;
                }
            }

            setIntervalTime(newInterval) {
                this.interval = newInterval;
                this.start();
            }

            handleVisibilityChange() {
                if (document.hidden) {
                    this.stop();
                } else {
                    this.start();
                }
            }
        }

        class Player {
            constructor(options) {
                this.scene = options.scene;
                this.world = options.world;
                this.game = options.game;
                this.renderer = options.renderer;
                this.input = options.input;
                this.eventEmitter = options.eventEmitter;
                this.cameraGroup = new THREE.Group();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.y = 1.6;
                this.cameraGroup.add(this.camera);
                this.scene.add(this.cameraGroup);

                this.healthyCount = 50;

                this.playerBody = new CANNON.Body({
                    mass: 1,
                    shape: new CANNON.Sphere(0.5),
                    position: new CANNON.Vec3(0, 1.6, 0),
                    material: new CANNON.Material({ friction: 0.3 }),
                    collisionFilterGroup: COLLISION_GROUP_PLAYER,
                    collisionFilterMask: COLLISION_GROUP_OBJECT
                });
                this.world.addBody(this.playerBody);

                this.yaw = 0;
                this.pitch = 0;
                this.grabbedObject = null;
                this.grabbedMesh = null;

                this.initMouseControls();
                this.initMouseClick();

                this.movementSound = new Audio('sounds/footsteps.mp3');
                this.movementSound.loop = true;
                this.isMovementSoundPlaying = false;
            }

            initMouseControls() {
                document.addEventListener('mousemove', (event) => {
                    if (document.pointerLockElement === this.renderer.domElement) {
                        this.yaw -= event.movementX * 0.002;
                        this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch - event.movementY * 0.002));
                        this.cameraGroup.rotation.y = this.yaw;
                        this.camera.rotation.x = this.pitch;
                    }
                });
            }

            initMouseClick() {
                document.addEventListener('mousedown', (event) => {
                    if (event.button === 0 || event.button === 2) {
                        this.tryGrabObject();
                    }
                });

                document.addEventListener('mouseup', (event) => {
                    if (event.button === 0 || event.button === 2) {
                        this.ungrabObject();
                    }
                });

                document.addEventListener('contextmenu', (event) => {
                    event.preventDefault();
                });
            }

            update() {
                this.handleMovement();
                this.updateCameraPosition();
            }

            handleMovement() {
                const direction = new THREE.Vector3(
                    (this.input.isKeyPressed('q') ? -1 : 0) + (this.input.isKeyPressed('d') ? 1 : 0),
                    0,
                    (this.input.isKeyPressed('z') ? -1 : 0) + (this.input.isKeyPressed('s') ? 1 : 0)
                ).applyAxisAngle(new THREE.Vector3(0, 1, 0), this.yaw);

                this.playerBody.velocity.x = direction.x * 2;
                this.playerBody.velocity.z = direction.z * 2;

                const isMoving = direction.length() > 0;
                if (isMoving && !this.isMovementSoundPlaying) {
                    this.movementSound.play();
                    this.isMovementSoundPlaying = true;
                } else if (!isMoving && this.isMovementSoundPlaying) {
                    this.movementSound.pause();
                    this.isMovementSoundPlaying = false;
                }
            }

            updateCameraPosition() {
                this.cameraGroup.position.copy(this.playerBody.position);
            }

            tryGrabObject() {
                if (this.grabbedObject) return;

                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2(0, 0);
                raycaster.setFromCamera(mouse, this.camera);
                raycaster.far = 2.5;

                const objectsToIntersect = [];
                this.scene.traverse((child) => {
                    if (child.isMesh && child.userData && child.userData.body && child.userData.body.mass > 0) {
                        objectsToIntersect.push(child);
                    }
                });

                const intersects = raycaster.intersectObjects(objectsToIntersect, true);
                for (let intersect of intersects) {
                    const object = intersect.object;
                    if (object.userData && object.userData.body && object.userData.body.mass > 0) {
                        this.grabbedObject = object.userData.body;
                        this.grabbedMesh = object;

                        this.disablePhysics(this.grabbedObject);

                        if (this.grabbedMesh.userData.gameObject) {
                            this.grabbedMesh.userData.gameObject.grab();
                        }

                        this.attachMeshToCamera(this.grabbedMesh);
                        break;
                    }
                }
            }

            ungrabObject() {
                if (!this.grabbedObject) return;

                this.detachMeshFromCamera(this.grabbedMesh);
                this.enablePhysics(this.grabbedObject);

                if (this.grabbedMesh.userData.gameObject) {
                    this.grabbedMesh.userData.gameObject.ungrab();
                }

                this.grabbedObject = null;
                this.grabbedMesh = null;
            }

            disablePhysics(body) {
                this.world.removeBody(body);
            }

            enablePhysics(body) {
                this.world.addBody(body);
                body.velocity.set(0, 0, 0);
                body.angularVelocity.set(0, 0, 0);
            }

            attachMeshToCamera(mesh) {
                const grabDistance = 1.5;
                mesh.position.set(0, 0, -grabDistance);
                mesh.quaternion.set(0, 0, 0, 1);
                this.camera.add(mesh);
            }

            detachMeshFromCamera(mesh) {
                mesh.updateMatrixWorld(true);
                const position = new THREE.Vector3();
                mesh.getWorldPosition(position);
                this.camera.remove(mesh);
                this.scene.add(mesh);
                this.grabbedObject.position.set(position.x, position.y, position.z);
                const rotation = new THREE.Quaternion();
                mesh.getWorldQuaternion(rotation);
                this.grabbedObject.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
            }
        }

        class Game {
            constructor() {
                this.eventEmitter = new EventEmitter();
                this.sceneManager = new SceneManager();
                this.physicsManager = new PhysicsManager();
                this.inputManager = new InputManager();
                this.dynamicObjects = [];
                this.conveyorBelts = [];
                this.BinLid = null;
                this.debug = false;
                this.gameOver = false;
                this.gameStartTime = null;
                this.gameEndTime = null;

                this.initInstructions();
                this.initWorld();
                this.initSounds();
                this.player = new Player({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    renderer: this.sceneManager.renderer,
                    input: this.inputManager,
                    eventEmitter: this.eventEmitter
                });

                window.addEventListener('resize', this.onWindowResize.bind(this));
                this.animate = this.animate.bind(this);

                this.conveyorSpeed = 2;
                this.trayGenerationInterval = 1800;
                this.difficulty = 0.6;

                this.trayGenerator = new IntervalExecutor(() => {
                    new Tray({
                        scene: this.sceneManager.scene,
                        world: this.physicsManager.world,
                        game: this,
                        isDynamic: true,
                        transform: {
                            position: { x: -5, y: 1, z: -7 },
                            size: { x: 1.4, y: 0.05, z: 1 }
                        },
                        physics: {
                            mass: 1,
                            friction: 0.3,
                        },
                        appearance: {
                            color: 0xF1F1FF,
                            shapeType: 'box',
                            opacity: 1
                        },
                        collider: {
                            type: 'box',
                            size: { x: 1.4, y: 0.05, z: 1 }
                        }
                    });
                }, this.trayGenerationInterval);
            }

            initInstructions() {
                const instructions = document.getElementById('instructions');
                const startButton = document.getElementById('start-button');

                const startGame = () => {
                    this.sceneManager.renderer.domElement.requestPointerLock();
                    instructions.style.display = 'none';
                    this.gameStartTime = Date.now();
                };

                startButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    startGame();
                });

                instructions.addEventListener('click', () => {
                    startGame();
                });

                document.addEventListener('pointerlockchange', () => {
                    if (document.pointerLockElement !== this.sceneManager.renderer.domElement) {
                        instructions.style.display = 'flex';
                    }
                });

                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible' && document.pointerLockElement !== this.sceneManager.renderer.domElement) {
                        instructions.style.display = 'flex';
                    }
                });
            }

            gameOverFunction(hasWon) {
                if (this.gameOver) return;
                this.gameOver = true;
                this.gameEndTime = Date.now();
                const elapsedTime = Math.floor((this.gameEndTime - this.gameStartTime) / 1000);

                const gameOverScreen = document.getElementById('gameOverScreen');
                const gameOverEmoji = document.getElementById('gameOverEmoji');
                const gameOverMessage = document.getElementById('gameOverMessage');
                const gameOverTimer = document.getElementById('gameOverTimer');

                if (hasWon) {
                    gameOverEmoji.textContent = 'üèÜ';
                    gameOverMessage.textContent = 'Vous avez gagn√© !';
                } else {
                    gameOverEmoji.textContent = 'üíÄ';
                    gameOverMessage.textContent = 'Vous avez perdu !';
                }

                gameOverTimer.textContent = `Temps √©coul√© : ${elapsedTime} secondes`;
                gameOverScreen.style.display = 'flex';

                gsap.to('#gameOverEmoji', { duration: 1, opacity: 1, ease: "bounce.out" });
                gsap.to('#gameOverMessage', { duration: 1, opacity: 1, delay: 0.5 });
                gsap.to('#gameOverTimer', { duration: 1, opacity: 1, delay: 1 });
            }

            initWorld() {
                const wallThickness = 0.5;
                const floorThickness = wallThickness;
                const roomSize = { x: 12, y: 5, z: 15 };
                const roomCenter = { x: -0.5, y: 2, z: -2 };

                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: roomCenter.x,
                            y: roomCenter.y - roomSize.y / 2 + floorThickness / 2,
                            z: roomCenter.z
                        },
                        size: { x: roomSize.x, y: floorThickness, z: roomSize.z }
                    },
                    physics: {
                        mass: 0,
                        friction: 0.5
                    },
                    appearance: {
                        texture: 'textures/floor.jpg',
                        repeating: true,
                        repeatDimensions: { x: 2, y: 2 },
                        shapeType: 'box',
                        opacity: 1
                    },
                    collider: {
                        type: 'box',
                        size: { x: roomSize.x, y: floorThickness, z: roomSize.z }
                    }
                });

                const walls = [
                    {
                        position: { x: roomCenter.x, y: roomCenter.y, z: roomCenter.z - roomSize.z / 2 - wallThickness / 2 },
                        size: { x: roomSize.x, y: roomSize.y, z: wallThickness },
                        color: 0x9e9e9e
                    },
                    {
                        position: { x: roomCenter.x, y: roomCenter.y, z: roomCenter.z + roomSize.z / 2 + wallThickness / 2 },
                        size: { x: roomSize.x, y: roomSize.y, z: wallThickness },
                        color: 0x5e5e5e
                    },
                    {
                        position: { x: roomCenter.x - roomSize.x / 2 - wallThickness / 2, y: roomCenter.y, z: roomCenter.z },
                        size: { x: wallThickness, y: roomSize.y, z: roomSize.z },
                        color: 0x5e5e5e
                    },
                    {
                        position: { x: roomCenter.x + roomSize.x / 2 + wallThickness / 2, y: roomCenter.y, z: roomCenter.z },
                        size: { x: wallThickness, y: roomSize.y, z: roomSize.z },
                        color: 0x5e5e5e
                    },
                    {
                        position: { x: roomCenter.x, y: roomCenter.y + roomSize.y / 2 - floorThickness / 2, z: roomCenter.z },
                        size: { x: roomSize.x, y: floorThickness, z: roomSize.z },
                        color: 0xcccccc
                    }
                ];

                walls.forEach(wall => {
                    new GameObject({
                        scene: this.sceneManager.scene,
                        world: this.physicsManager.world,
                        game: this,
                        transform: {
                            position: wall.position,
                            size: wall.size
                        },
                        physics: {
                            mass: 0
                        },
                        appearance: {
                            color: wall.color,
                            shapeType: 'box'
                        },
                        collider: {
                            type: 'box',
                            size: wall.size
                        }
                    });
                });

                const additionalObjects = [
                    {
                        transform: {
                            position: { x: 5, y: 0.2, z: 5.4 },
                            size: { x: 2, y: 2, z: 0.1 }
                        },
                        model: { path: 'models/environments/window.glb' }
                    },
                    {
                        transform: {
                            position: { x: -6.5, y: 0.2, z: -7 },
                            size: { x: 2, y: 2, z: 0.1 },
                            rotation: { x: 0, y: Math.PI / 2, z: 0 }
                        },
                        model: { path: 'models/environments/window.glb' }
                    },
                    {
                        transform: {
                            position: { x: roomCenter.x, y: -0.1, z: -9.69 },
                            size: { x: 1, y: 2, z: 0.1 }
                        },
                        model: { path: 'models/environments/door.glb' }
                    },
                    {
                        transform: {
                            position: { x: -0.5, y: 3.4, z: -2 },
                            size: { x: 1, y: 2, z: 0.1 }
                        },
                        model: { path: 'models/environments/light.glb' }
                    }
                ];

                additionalObjects.forEach(obj => {
                    new GameObject({
                        scene: this.sceneManager.scene,
                        world: this.physicsManager.world,
                        game: this,
                        transform: obj.transform,
                        model: obj.model
                    });
                });

                new TrayReceptor({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    isDynamic: true,
                    transform: {
                        position: { x: 4, y: 1.5, z: -9.4 },
                        size: { x: 0.1, y: 2, z: 2 },
                        rotation: { x: 0, y: Math.PI / 2, z: 0 }
                    },
                    physics: {
                        mass: 0
                    },
                    appearance: {
                        color: 0x000000,
                        shapeType: 'box',
                        opacity: 1
                    },
                    collider: {
                        type: 'box',
                        size: { x: 0.1, y: 2, z: 2 }
                    }
                });

                this.BinLid = new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: { x: -0.5, y: 1.60, z: -1.97 },
                        size: { x: 1.2, y: 0.05, z: 0.7 },
                        rotation: { x: 0, y: 0, z: 0 }
                    },
                    appearance: {
                        color: 0x969696,
                        shapeType: 'box',
                        opacity: 1
                    }
                });

                new Bin({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    isDynamic: true,
                    transform: {
                        position: { x: -0.5, y: 0.75, z: -2 },
                        size: { x: 1, y: 1.5, z: 0.5 },
                        rotation: { x: 0, y: 0, z: 0 }
                    },
                    physics: {
                        mass: 0
                    },
                    model: {
                        path: 'models/environments/trash.glb'
                    },
                    collider: {
                        type: 'box',
                        size: { x: 1, y: 1.5, z: 0.5 }
                    }
                });

                const conveyorBelt1 = new ConveyorBelt({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    isDynamic: true,
                    transform: {
                        position: { x: -5, y: 0.5, z: -2.5 },
                        rotation: { x: 0, y: -Math.PI / 2, z: 0 },
                        size: { x: 10, y: 1.5, z: 2 }
                    },
                    appearance: {
                        color: 0x000000,
                        opacity: 1,
                        shapeType: 'box'
                    },
                    physics: {
                        mass: 0,
                        friction: 0
                    },
                    collider: {
                        type: 'box',
                        size: { x: 10, y: 1.5, z: 2 }
                    },
                    speed: this.conveyorSpeed
                });

                const conveyorBelt2 = new ConveyorBelt({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    isDynamic: true,
                    transform: {
                        position: { x: -1, y: 0.499, z: 3 },
                        size: { x: 10, y: 1.5, z: 2 },
                        rotation: { x: 0, y: 0, z: 0 }
                    },
                    appearance: {
                        color: 0x000000,
                        opacity: 1,
                        shapeType: 'box'
                    },
                    physics: {
                        mass: 0,
                        friction: 0
                    },
                    collider: {
                        type: 'box',
                        size: { x: 10, y: 1.5, z: 2 }
                    },
                    speed: this.conveyorSpeed
                });

                const conveyorBelt3 = new ConveyorBelt({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    isDynamic: true,
                    transform: {
                        position: { x: 4, y: 0.498, z: -3 },
                        size: { x: 14, y: 1.5, z: 2 },
                        rotation: { x: 0, y: Math.PI / 2, z: 0 }
                    },
                    appearance: {
                        color: 0x000000,
                        opacity: 1,
                        shapeType: 'box'
                    },
                    physics: {
                        mass: 0,
                        friction: 0
                    },
                    collider: {
                        type: 'box',
                        size: { x: 14, y: 1.5, z: 2 }
                    },
                    speed: this.conveyorSpeed
                });

                this.conveyorBelts.push(conveyorBelt1, conveyorBelt2, conveyorBelt3);

                const decorativeConveyors = [
                    {
                        transform: {
                            position: { x: 4, y: 0.3, z: -2.5 },
                            size: { x: 1.4, y: 1.5, z: 2 },
                            rotation: { x: 0, y: Math.PI / 2, z: 0 }
                        },
                        model: { path: 'models/environments/conveyor.glb' }
                    },
                    {
                        transform: {
                            position: { x: -5, y: 0.3, z: -2.5 },
                            size: { x: 1.4, y: 1.5, z: 2 },
                            rotation: { x: 0, y: Math.PI / 2, z: 0 }
                        },
                        model: { path: 'models/environments/conveyor.glb' }
                    },
                    {
                        transform: {
                            position: { x: -0.5, y: 0.3, z: 3 },
                            size: { x: 1.4, y: 1.5, z: 2 },
                            rotation: { x: 0, y: 0, z: 0 }
                        },
                        model: { path: 'models/environments/conveyor2.glb' }
                    },
                    {
                        transform: {
                            position: { x: -5, y: -0.2, z: -6.90 },
                            size: { x: 1.4, y: 1.5, z: 2 },
                            rotation: { x: 0, y: Math.PI / 2, z: Math.PI / 2 }
                        },
                        model: { path: 'models/environments/conveyor_hole.glb' }
                    },
                    {
                        transform: {
                            position: { x: 4, y: 1.8, z: -9 },
                            size: { x: 1.4, y: 1.5, z: 2 },
                            rotation: { x: 0, y: Math.PI / 2, z: 0 }
                        },
                        model: { path: 'models/environments/conveyor_hole.glb' }
                    }
                ];

                decorativeConveyors.forEach(conveyor => {
                    new GameObject({
                        scene: this.sceneManager.scene,
                        world: this.physicsManager.world,
                        game: this,
                        transform: conveyor.transform,
                        model: conveyor.model
                    });
                });
            }

            initSounds() {
                const audio = new Audio('sounds/conveyor.mp3');
                audio.volume = 0.06;
                audio.loop = true;
                audio.play();
            }

            animate() {
                requestAnimationFrame(this.animate);
                this.physicsManager.step();
                this.dynamicObjects.forEach(obj => obj.update());
                this.player.update();
                this.sceneManager.render(this.player.camera);
            }

            start() {
                this.animate();
            }

            onWindowResize() {
                this.player.camera.aspect = window.innerWidth / window.innerHeight;
                this.player.camera.updateProjectionMatrix();
                this.sceneManager.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        const game = new Game();
        game.start();
    </script>
</body>

</html>
