<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title>Jeu 3D avec Three.js et Cannon.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 600px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            /* Fond semi-transparent pour l'√©cran de d√©marrage */
            border-radius: 10px;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            user-select: none;
            cursor: pointer;
            z-index: 1500;
            /* Assurez-vous qu'il est en dessous de gameOverScreen */
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .instruction-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 5px;
        }

        .instruction-text {
            font-size: 1.2rem;
        }

        .instruction-icon {
            font-size: 2rem;
            /* Si vous utilisez des PNG, ajustez la taille en cons√©quence */
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Style du bouton de d√©marrage */
        #start-button {
            padding: 10px 20px;
            font-size: 1.5rem;
            border: none;
            border-radius: 5px;
            background-color: #28a745;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #start-button:hover {
            background-color: #218838;
        }

        /* Style du paragraphe de description */
        .game-description {
            font-size: 1rem;
            padding: 0 20px;
        }

        /* Style du crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            margin-left: -5px;
            /* Pour centrer horizontalement */
            margin-top: -5px;
            /* Pour centrer verticalement */
            background-color: white;
            border: 2px solid black;
            border-radius: 50%;
            pointer-events: none;
            /* Permet de cliquer √† travers le crosshair */
            z-index: 1000;
        }

        /* --- D√©but des Styles du Slider --- */

        .slider-container {
            position: absolute;
            /* Positionnement absolu pour placer le slider sur l'√©cran */
            bottom: 10px;
            /* Positionner le slider en bas */
            left: 50%;
            /* Centrer horizontalement */
            transform: translateX(-50%);
            /* Centrer pr√©cis√©ment */
            display: flex;
            align-items: center;
            width: 400px;
            /* Augment√© de 300px √† 400px */
            z-index: 1000;
            /* Assurer que le slider est au-dessus des autres √©l√©ments */
        }

        .emoji {
            font-size: 3rem;
            /* Augment√© de 2rem √† 3rem */
            margin: 0 15px;
            /* Augment√© de 10px √† 15px */
            transition: font-size 0.3s, transform 0.3s;
        }

        /* Styles du slider */
        .slider {
            -webkit-appearance: none;
            /* Supprimer le style par d√©faut pour Chrome, Safari, Edge */
            appearance: none;
            width: 100%;
            height: 15px;
            /* Augment√© de 10px √† 15px */
            border-radius: 7.5px;
            /* Ajust√© pour le nouvel height */
            background: linear-gradient(to right, red, green);
            outline: none;
            margin: 0;
            padding: 0;
            transition: background 0.3s;
            position: relative;
            pointer-events: none;
            /* Emp√™cher toute interaction utilisateur */
        }

        .slider:hover {
            background: linear-gradient(to right, darkred, darkgreen);
        }

        /* Pointeur du slider personnalis√© pour Webkit (Chrome, Safari, Edge) */
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 40px;
            /* Augment√© de 30px √† 40px */
            height: 40px;
            /* Augment√© de 30px √† 40px */
            background: url('textures/cursor.png') no-repeat center;
            background-size: contain;
            cursor: pointer;
            margin-top: -50px;
            /* Centrer verticalement le curseur (40px height) */
            /* 15px height slider / 2 - 40px height thumb / 2 = -12.5px */
            border: none;
            /* Supprimer toute bordure par d√©faut */
            /* R√©activer les √©v√©nements pour le curseur */
        }

        /* Pointeur du slider personnalis√© pour Firefox */
        .slider::-moz-range-thumb {
            width: 40px;
            /* Augment√© de 30px √† 40px */
            height: 40px;
            /* Augment√© de 30px √† 40px */
            background: url('textures/cursor.png') no-repeat center;
            background-size: contain;
            cursor: pointer;
            border: none;
            /* Supprimer toute bordure par d√©faut */
            /* Alignement vertical similaire √† Webkit */
            transform: translateY(-12.5px);
            /* Ajust√© pour la nouvelle taille */
            /* Optionnel : ajouter une l√©g√®re ombre pour un meilleur contraste */
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
            pointer-events: all;
            /* R√©activer les √©v√©nements pour le curseur */
        }

        /* Pour Firefox : supprimer le contour lors du focus */
        .slider::-moz-focus-outer {
            border: 0;
        }

        /* Styles suppl√©mentaires pour l'accessibilit√© et l'apparence */
        .slider:focus {
            outline: none;
        }

        /* Styles pour l'√©cran de fin de jeu */
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            /* Fond l√©g√®rement diff√©rent */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 2000;
            /* Au-dessus de tout */
        }

        #gameOverContent {
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .game-over-emoji {
            font-size: 5rem;
            margin-bottom: 20px;
            opacity: 0;
            /* Invisible au d√©part */
            transform: translateY(50px);
            /* Position initiale pour l'animation */
        }

        .game-over-message {
            font-size: 2.5rem;
            margin-bottom: 10px;
            opacity: 0;
            /* Invisible au d√©part */
        }

        .game-over-timer {
            font-size: 1.5rem;
            opacity: 0;
            /* Invisible au d√©part */
        }

        /* --- Fin des Styles du Slider --- */
    </style>
</head>

<body>
    <div id="instructions">
        <!-- Instructions de contr√¥le -->
        <div class="instruction-item">
            <span class="instruction-text">Attraper les plateaux avec clic droit</span>
            <span class="instruction-icon">üîÑ</span>
            <!-- Remplacez l'emoji üîÑ par votre PNG si n√©cessaire -->
            <!-- <span class="instruction-icon"><img src="path/to/clic-droit.png" alt="Clic Droit" width="40" height="40"></span> -->
        </div>
        <div class="instruction-item">
            <span class="instruction-text">Se d√©placer avec ZQSD</span>
            <span class="instruction-icon">üïπÔ∏è</span>
            <!-- Remplacez l'emoji üïπÔ∏è par votre PNG si n√©cessaire -->
            <!-- <span class="instruction-icon"><img src="path/to/zqsd.png" alt="ZQSD" width="40" height="40"></span> -->
        </div>

        <!-- Description du jeu -->
        <p class="game-description">
            Devenez le h√©ros silencieux d‚Äôun lyc√©e en crise nutritionnelle. En tant que cantinier, vous vous souciez de la sant√© des √©l√®ves. C'est pourquoi vous n'h√©sitez pas √† jeter √† la poubelle les plateaux mauvais pour maintenir la bonne sant√© des √©l√®ves. Un conseil soyez rapide !
        </p>

        <!-- Bouton de d√©marrage -->
        <button id="start-button">Cliquez pour d√©marrer</button>
    </div>
    <div id="crosshair"></div> <!-- Ajout du crosshair -->

    <!-- Remplacement du Div #healthyCount par le Slider -->
    <div class="slider-container">
        <span class="emoji" id="leftEmoji">üòà</span>
        <input type="range" min="0" max="100" value="50" class="slider" id="healthySlider" disabled>
        <span class="emoji" id="rightEmoji">üòé</span>
    </div>

    <!-- √âcran de fin de jeu -->
    <div id="gameOverScreen" style="display: none;">
        <div id="gameOverContent">
            <span id="gameOverEmoji" class="game-over-emoji"></span>
            <h1 id="gameOverMessage" class="game-over-message"></h1>
            <p id="gameOverTimer" class="game-over-timer"></p>
        </div>
    </div>


    <!-- Script Three.js et autres scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>

    <!-- --- D√©but des Scripts du Slider --- -->
    <!-- Inclusion de GSAP via CDN sans l'attribut integrity -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js" crossorigin="anonymous"
        referrerpolicy="no-referrer"></script>
    <script>
        let previousValue = 0; // Variable pour stocker la valeur pr√©c√©dente du slider

        // Fonction pour mettre √† jour le slider en fonction du healthyCount
        function updateHealthySlider(count) {
            const slider = document.getElementById('healthySlider');
            slider.value = count;

            // Calculer les tailles des emojis
            const leftEmoji = document.getElementById('leftEmoji');
            const rightEmoji = document.getElementById('rightEmoji');

            // Normaliser la valeur du slider (supposons min=-100, max=100)
            // La taille varie de 1rem √† 4rem
            const leftSize = 4 - ((count + 100) / 200) * 3; // de 4rem √† 1rem
            const rightSize = 1 + ((count + 100) / 200) * 3; // de 1rem √† 4rem

            // Utiliser GSAP pour animer les changements de taille
            gsap.to(leftEmoji, { duration: 0.3, fontSize: `${leftSize}rem` });
            gsap.to(rightEmoji, { duration: 0.3, fontSize: `${rightSize}rem` });

            // D√©tecter la direction du changement pour animer les emojis
            if (count > previousValue) {
                // Valeur a augment√©, animer l'emoji de droite
                gsap.fromTo(rightEmoji, { scale: 1 }, { scale: 2, duration: 0.2, yoyo: true, repeat: 1 });
            } else if (count < previousValue) {
                // Valeur a diminu√©, animer l'emoji de gauche
                gsap.fromTo(leftEmoji, { scale: 1 }, { scale: 2, duration: 0.2, yoyo: true, repeat: 1 });
            }
            previousValue = count;
        }

        // Exposer la fonction globalement pour qu'elle puisse √™tre appel√©e depuis d'autres classes
        window.updateHealthySlider = updateHealthySlider;
    </script>
    <script>
        // Pour pas oublier, il faut que je cr√©e un g√©n√©rateur de plateau et. Et ensuite ? Ensuite Une classe g√©n√©rateur de plateau on. Ensuite, il faut que je fasse en sorte que les choses qui peuvent √™tre upgradeable sont la distance pour attraper un objet et aussi. Il faut savoir que en fait, les plateaux auront un indice de mauvaise bouffe et plus on avance Plus les plateaux auront condense √† √™tre dans la mauvaise bouffe et avoir un indice √©lev√© de mauvaise bouffe. Et du coup, le joueur devra essayer de de vu qu'il pourra pas attraper tous les plateaux, il devra attraper les plateaux qu'ils ont le plus gros indice de mauvaise bouffe. Ensuite La vitesse de d√©placement sera aussi un √©l√©ment qui sera upgradable
        // D√©finir les groupes de collision
        const COLLISION_GROUP_PLAYER = 1 << 0; // 1
        const COLLISION_GROUP_OBJECT = 1 << 1; // 2

        // Gestionnaire des √©v√©nements
        class EventEmitter {
            constructor() {
                this.events = {};
            }

            on(event, listener) {
                if (!this.events[event]) {
                    this.events[event] = [];
                }
                this.events[event].push(listener);
            }

            emit(event, data) {
                if (this.events[event]) {
                    this.events[event].forEach(listener => listener(data));
                }
            }
        }

        // Gestionnaire de la sc√®ne Three.js
        class SceneManager {
            constructor() {
                this.scene = new THREE.Scene();
                // Ajout d'une lumi√®re directionnelle pour mieux voir les objets
                //const light = new THREE.DirectionalLight(0xffffff, 1);
                //light.position.set(5, 10, 7.5);
                //this.scene.add(light);

                // Ajout d'une lumi√®re ambiante
                const ambientLight = new THREE.AmbientLight(0xe0e0e0); // lumi√®re douce
                this.scene.add(ambientLight);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement);
            }

            render(camera) {
                this.renderer.render(this.scene, camera);
            }
        }

        // Gestionnaire de la physique Cannon.js
        class PhysicsManager {
            constructor() {
                this.world = new CANNON.World();
                this.world.gravity.set(0, -9.82, 0);
                this.fixedTimeStep = 1 / 60;
                this.maxSubSteps = 3;
            }

            step() {
                this.world.step(this.fixedTimeStep, undefined, this.maxSubSteps);
            }
        }

        // Gestionnaire des entr√©es utilisateur
        class InputManager {
            constructor() {
                this.keys = {};
                this.listeners = {};

                this.initControls();
            }

            initControls() {
                document.addEventListener('keydown', (e) => this.onKeyChange(e, true));
                document.addEventListener('keyup', (e) => this.onKeyChange(e, false));
            }

            onKeyChange(event, isPressed) {
                const key = event.key.toLowerCase();
                this.keys[key] = isPressed;

                if (this.listeners[key]) {
                    this.listeners[key].forEach(callback => callback(isPressed));
                }
            }

            bindKey(key, callback) {
                key = key.toLowerCase();
                if (!this.listeners[key]) {
                    this.listeners[key] = [];
                }
                this.listeners[key].push(callback);
            }

            isKeyPressed(key) {
                return !!this.keys[key.toLowerCase()];
            }
        }

        // Classe repr√©sentant un objet du jeu
        class GameObject {
            constructor(options) {
                this.scene = options.scene;
                this.world = options.world;
                this.game = options.game;

                // Fusion des options avec les valeurs par d√©faut
                const defaultTransform = {
                    position: { x: 0, y: 0, z: 0 },
                    rotation: { x: 0, y: 0, z: 0 },
                    size: { x: 1, y: 1, z: 1 }
                };
                const defaultAppearance = {
                    color: 0xffffff,
                    opacity: 1,
                    texture: null, // Chaque GameObject n'a qu'une seule texture
                    repeating: false, // Indique si la texture est en r√©p√©tition
                    repeatDimensions: { x: 1, y: 1 }, // Dimensions de r√©p√©tition
                    shapeType: 'box'
                };
                const defaultModel = { path: null };
                const defaultIsDynamic = false;

                this.transform = Object.assign({}, defaultTransform, options.transform);
                this.transform.position = Object.assign({}, defaultTransform.position, options.transform?.position);
                this.transform.rotation = Object.assign({}, defaultTransform.rotation, options.transform?.rotation);
                this.transform.size = Object.assign({}, defaultTransform.size, options.transform?.size);

                this.appearance = Object.assign({}, defaultAppearance, options.appearance);
                this.model = Object.assign({}, defaultModel, options.model);
                this.isDynamic = options.isDynamic ?? defaultIsDynamic;

                // Initialiser la physique et le collider uniquement si fournis
                this.physics = options.physics ? Object.assign({}, options.physics) : null;
                if (this.physics) {
                    this.body = new CANNON.Body({
                        mass: this.physics.mass,
                        position: new CANNON.Vec3(
                            this.transform.position.x,
                            this.transform.position.y,
                            this.transform.position.z
                        ),
                        material: new CANNON.Material({ friction: this.physics.friction }),
                        quaternion: new CANNON.Quaternion().setFromEuler(
                            this.transform.rotation.x,
                            this.transform.rotation.y,
                            this.transform.rotation.z,
                            'XYZ'
                        ),
                        collisionFilterGroup: COLLISION_GROUP_OBJECT,
                        collisionFilterMask: COLLISION_GROUP_PLAYER | COLLISION_GROUP_OBJECT
                    });

                    if (options.collider) {
                        this.collider = Object.assign({}, options.collider);
                        this.setCollider();
                    }

                    this.world.addBody(this.body);
                } else {
                    this.body = null;
                }

                // Charger ou cr√©er le mod√®le visuel
                this.initVisual();

                // Ajouter l'objet aux objets dynamiques de la sc√®ne
                if (this.isDynamic) {
                    this.game.dynamicObjects.push(this);
                }

                // Indique si l'objet est actuellement attrap√©
                this.isGrabbed = false;
            }

            setCollider() {
                const { type, size } = this.collider;
                let shape;
                switch (type) {
                    case 'sphere':
                        shape = new CANNON.Sphere(size.x / 2);
                        break;
                    case 'cylinder':
                        shape = new CANNON.Cylinder(size.x / 2, size.x / 2, size.y, 12);
                        break;
                    case 'box':
                    default:
                        shape = new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));
                }
                this.body.addShape(shape);
            }

            initVisual() {
                const { color, opacity, texture, repeating, repeatDimensions, shapeType } = this.appearance;
                const { size } = this.transform;

                // Cr√©ation du mat√©riau
                const materialOptions = {
                    color: color,
                    transparent: opacity < 1,
                    opacity: opacity
                };

                if (texture) {
                    const textureLoader = new THREE.TextureLoader();
                    const loadedTexture = textureLoader.load(texture);
                    if (repeating) {
                        loadedTexture.wrapS = loadedTexture.wrapT = THREE.RepeatWrapping;
                        loadedTexture.repeat.set(repeatDimensions.x, repeatDimensions.y);
                    }
                    materialOptions.map = loadedTexture;
                }

                const material = new THREE.MeshStandardMaterial(materialOptions);

                // Cr√©ation du maillage
                if (this.model.path) {
                    const loader = new THREE.GLTFLoader();
                    loader.load(this.model.path, (gltf) => {
                        this.mesh = gltf.scene;
                        this.mesh.userData.gameObject = this;
                        this.applyTransformations();
                        this.scene.add(this.mesh);

                        // Associer le corps physique aux maillages enfants
                        if (this.body) {
                            this.mesh.traverse((child) => {
                                if (child.isMesh) {
                                    child.userData.body = this.body;
                                }
                            });
                        }

                        if (this.body) {
                            this.addColliderHelper();
                        }
                    });
                } else {
                    this.createDefaultMesh(shapeType, material, size);
                }
            }

            createDefaultMesh(shapeType, material, size) {
                switch (shapeType) {
                    case 'sphere':
                        this.mesh = new THREE.Mesh(new THREE.SphereGeometry(size.x / 2, 32, 32), material);
                        break;
                    case 'cylinder':
                        this.mesh = new THREE.Mesh(
                            new THREE.CylinderGeometry(size.x / 2, size.x / 2, size.y, 12),
                            material
                        );
                        break;
                    case 'box':
                    default:
                        this.mesh = new THREE.Mesh(new THREE.BoxGeometry(size.x, size.y, size.z), material);
                }
                this.mesh.userData.gameObject = this;
                this.applyTransformations();
                this.scene.add(this.mesh);

                if (this.body) {
                    this.mesh.userData.body = this.body;
                    this.addColliderHelper();
                }
            }

            applyTransformations() {
                if (this.mesh) {
                    this.mesh.position.set(
                        this.transform.position.x,
                        this.transform.position.y,
                        this.transform.position.z
                    );
                    this.mesh.rotation.set(
                        this.transform.rotation.x,
                        this.transform.rotation.y,
                        this.transform.rotation.z
                    );
                    if (this.body) {
                        this.mesh.position.copy(this.body.position);
                        this.mesh.quaternion.copy(this.body.quaternion);
                    }
                }
            }

            addColliderHelper() {
                if (!this.game.debug) return;
                if (!this.body || !this.body.shapes[0]) return;

                let geometry;
                const shape = this.body.shapes[0];
                switch (shape.type) {
                    case CANNON.Shape.types.BOX:
                        const halfExtents = shape.halfExtents;
                        geometry = new THREE.BoxGeometry(
                            halfExtents.x * 2,
                            halfExtents.y * 2,
                            halfExtents.z * 2
                        );
                        break;
                    case CANNON.Shape.types.SPHERE:
                        const radius = shape.radius;
                        geometry = new THREE.SphereGeometry(radius, 16, 16);
                        break;
                    case CANNON.Shape.types.CYLINDER:
                        const radiusTop = shape.radiusTop;
                        const radiusBottom = shape.radiusBottom;
                        const height = shape.height;
                        geometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, 16);
                        break;
                    default:
                        console.warn('Type de forme non reconnu pour la visualisation du collider.');
                        return;
                }
                const material = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const helper = new THREE.Mesh(geometry, material);
                helper.name = 'ColliderHelper';
                this.scene.add(helper);

                helper.position.copy(this.body.position);
                helper.quaternion.copy(this.body.quaternion);

                if (this.body.mass > 0) {
                    this.updateColliderHelper = () => {
                        helper.position.copy(this.body.position);
                        helper.quaternion.copy(this.body.quaternion);
                    };
                }
            }

            grab() {
                this.isGrabbed = true;
            }

            ungrab() {
                this.isGrabbed = false;
            }

            update() {
                if (this.isGrabbed) return;

                if (this.body && this.mesh) {
                    this.mesh.position.copy(this.body.position);
                    this.mesh.quaternion.copy(this.body.quaternion);
                    if (this.updateColliderHelper) {
                        this.updateColliderHelper();
                    }
                }
            }
        }

        class Tray extends GameObject {
            constructor(options) {
                super(options);
                this.type = 'tray'; // D√©finir le type plateau
                this.healthyCount = 0; // Compteur de malbouffe
                this.healthyFoodModels = [
                    'models/foods/soda.glb',
                    'models/foods/apple.glb',
                    'models/foods/pineapple.glb',
                    'models/foods/banana.glb',
                    'models/foods/strawberries.glb',
                    'models/foods/tomato.glb',
                    // Ajoutez les chemins vers vos mod√®les de nourriture saine ici
                ];

                this.unhealthyFoodModels = [
                    'models/foods/burger.glb',
                    'models/foods/hotdog.glb',
                    'models/foods/chips.glb',
                    'models/foods/pizza.glb',
                    'models/foods/donut.glb',
                    'models/foods/egg.glb',
                    'models/foods/icecream.glb',
                    'models/foods/chocolate.glb',
                    'models/foods/cupcake.glb',
                    // Ajoutez les chemins vers vos mod√®les de nourriture non saine ici
                ];

                this.initFood();
            }

            initFood() {
                const positions = [
                    { x: -0.5, y: 0.02, z: -0.3 },
                    { x: 0, y: 0.02, z: -0.3 },
                    { x: 0.5, y: 0.02, z: -0.3 },
                    { x: -0.5, y: 0.02, z: 0.3 },
                    { x: 0, y: 0.02, z: 0.3 },
                    { x: 0.5, y: 0.02, z: 0.3 }
                ];

                const loader = new THREE.GLTFLoader();
                const count = Math.floor(Math.random() * 6) + 1;
                const shuffled = positions.sort(() => 0.5 - Math.random()).slice(0, count);

                shuffled.forEach(position => {
                    // G√©n√©rer un nombre al√©atoire entre 0 et 1
                    const randomValue = Math.random();
                    let modelPath;

                    // S√©lectionner la nourriture en fonction de la difficult√©
                    if (randomValue < 1 - this.game.difficulty) {
                        // Plus de chances de choisir un mod√®le sain si la difficult√© est basse
                        modelPath = this.healthyFoodModels[Math.floor(Math.random() * this.healthyFoodModels.length)];
                        this.healthyCount++; // Incr√©menter le compteur pour la nourriture saine
                    } else {
                        // Plus de chances de choisir un mod√®le malsain si la difficult√© est haute
                        modelPath = this.unhealthyFoodModels[Math.floor(Math.random() * this.unhealthyFoodModels.length)];
                        this.healthyCount--; // Incr√©menter le compteur pour la malbouffe
                    }

                    // Charger le mod√®le
                    loader.load(modelPath, gltf => {
                        const food = gltf.scene;
                        food.position.set(position.x, position.y, position.z);
                        this.mesh.add(food);
                    });
                });
            }
        }

        class TrayReceptor extends GameObject {
            constructor(options) {
                super(options);
            }

            update() {
                this.game.dynamicObjects.forEach(obj => {
                    const body = obj.body;
                    if (this.isInContact(body)) {
                        // Mettre √† jour le healthyCount
                        if (obj.type === 'tray') {
                            // Ajouter la variable de nourriture saine du plateau
                            this.game.player.healthyCount += obj.healthyCount;

                            // Mettre √† jour le slider
                            window.updateHealthySlider(this.game.player.healthyCount);
                            // V√©rifier les conditions de fin de jeu
                            if (this.game.player.healthyCount <= 0) {
                                this.game.gameOverFunction(false); // D√©faite
                            } else if (this.game.player.healthyCount >= 100) {
                                this.game.gameOverFunction(true); // Victoire
                            }

                            // D√©truire le tray
                            this.scene.remove(obj.mesh);
                            this.world.removeBody(obj.body);
                        }
                    }
                });
                super.update();
            }

            isInContact(body) {
                return this.world.contacts.some(contact => {
                    return (
                        (contact.bi === this.body && contact.bj === body) ||
                        (contact.bj === this.body && contact.bi === body)
                    );
                });
            }
        }

        class Bin extends GameObject {
            constructor(options) {
                super(options);

                // Acc√®s √† l'objet couvercle
                this.lid = this.game.BinLid;

                // Variables pour l'animation d'ouverture/fermeture
                this.isAnimating = false;
                this.targetRotation = 0;  // La rotation cible du couvercle
                this.openRotation = -Math.PI / 2;  // Rotation de 90¬∞ pour ouvrir
                this.closeRotation = 0;  // Rotation ferm√©e

                // Timer pour fermer le couvercle apr√®s ouverture
                this.closeLidTimer = null;
            }

            update() {
                this.game.dynamicObjects.forEach(obj => {
                    const body = obj.body;
                    if (this.isInContact(body) && obj.type === 'tray') {
                        // Supprimer l'objet de la sc√®ne et de la physique
                        this.scene.remove(obj.mesh);
                        this.world.removeBody(obj.body);

                        // Jouer le son de la poubelle
                        const audio = new Audio('sounds/trash.wav');
                        audio.volume = 0.3;
                        audio.play();

                        // D√©clencher l'animation d'ouverture
                        this.toggleLid();
                    }
                });

                // Si l'animation est active, mettre √† jour la rotation du couvercle
                if (this.isAnimating) {
                    this.animateLid();
                }

                super.update();
            }

            toggleLid() {
                // Basculer entre l'ouverture et la fermeture
                if (this.isAnimating) return; // Emp√™cher de basculer pendant une animation

                this.targetRotation = (this.lid.transform.rotation.x === this.closeRotation) ? this.openRotation : this.closeRotation;
                this.isAnimating = true; // Activer l'animation

                // Si on ouvre le couvercle, lancer un timer pour le refermer apr√®s 2 secondes
                if (this.targetRotation === this.openRotation) {
                    // Effacer tout timer existant pour √©viter les fermetures multiples
                    if (this.closeLidTimer) {
                        clearTimeout(this.closeLidTimer);
                    }

                    this.closeLidTimer = setTimeout(() => {
                        this.toggleLid(); // Refermer le couvercle
                    }, 500); // 2000 ms = 2 secondes
                } else {
                    // Si on ferme le couvercle, effacer le timer de fermeture si n√©cessaire
                    if (this.closeLidTimer) {
                        clearTimeout(this.closeLidTimer);
                        this.closeLidTimer = null;
                    }
                }
            }

            animateLid() {
                // Interpoler la rotation actuelle vers la rotation cible
                this.lid.transform.rotation.x += (this.targetRotation - this.lid.transform.rotation.x) * 0.1;

                // Appliquer les transformations au maillage visuel
                this.lid.applyTransformations();

                // Si proche de la cible, arr√™ter l'animation
                if (Math.abs(this.targetRotation - this.lid.transform.rotation.x) < 0.01) {
                    this.lid.transform.rotation.x = this.targetRotation;  // Fixer √† la cible
                    this.lid.applyTransformations(); // Assurer que la rotation finale est appliqu√©e
                    this.isAnimating = false;  // D√©sactiver l'animation

                    // Si on vient de fermer le couvercle, effacer le timer
                    if (this.targetRotation === this.closeRotation && this.closeLidTimer) {
                        clearTimeout(this.closeLidTimer);
                        this.closeLidTimer = null;
                    }
                }
            }

            isInContact(body) {
                return this.world.contacts.some(contact => {
                    return (
                        (contact.bi === this.body && contact.bj === body) ||
                        (contact.bj === this.body && contact.bi === body)
                    );
                });
            }
        }

        class ConveyorBelt extends GameObject {
            constructor(options) {
                super(options);

                this.speed = options.speed || 0.5;

                // D√©finir la rotation initiale
                const rotation = options.transform.rotation || new THREE.Vector3(0, 0, 0);
                const euler = new THREE.Euler(rotation.x, rotation.y, rotation.z, 'XYZ');

                // Calculer la direction bas√©e sur la rotation initiale
                this.direction = new THREE.Vector3(1, 0, 0).applyEuler(euler).normalize();
            }

            setSpeed(newSpeed) {
                this.speed = newSpeed;
            }

            update() {
                this.game.dynamicObjects.forEach(obj => {
                    const body = obj.body;
                    if (this.isInContact(body)) {
                        // Appliquer la v√©locit√© en fonction de la direction fixe
                        body.velocity.set(
                            this.direction.x * this.speed,
                            body.velocity.y,
                            this.direction.z * this.speed
                        );
                    }
                });
                super.update();
            }

            isInContact(body) {
                return this.world.contacts.some(contact => {
                    return (
                        (contact.bi === this.body && contact.bj === body) ||
                        (contact.bj === this.body && contact.bi === body)
                    );
                });
            }
        }

        class IntervalExecutor {
            constructor(callback, interval) {
                this.callback = callback;
                this.interval = interval;
                this.timerId = null;
                this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
                this.start();
                document.addEventListener('visibilitychange', this.handleVisibilityChange);
            }

            start() {
                this.stop(); // Ensure no multiple timers
                if (!document.hidden) {
                    this.timerId = setInterval(this.callback, this.interval);
                }
            }

            stop() {
                if (this.timerId !== null) {
                    clearInterval(this.timerId);
                    this.timerId = null;
                }
            }

            setIntervalTime(newInterval) {
                this.interval = newInterval;
                this.start();
            }

            handleVisibilityChange() {
                if (document.hidden) {
                    this.stop();
                } else {
                    this.start();
                }
            }
        }

        // Classe repr√©sentant le joueur
        class Player {
            constructor(options) {
                this.scene = options.scene;
                this.world = options.world;
                this.renderer = options.renderer;
                this.input = options.input;
                this.eventEmitter = options.eventEmitter;
                this.cameraGroup = new THREE.Group();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.y = 1.6;
                this.cameraGroup.add(this.camera);
                this.scene.add(this.cameraGroup);

                // Initialiser le joueur
                this.healthyCount = 50;

                // Corps physique du joueur
                this.playerBody = new CANNON.Body({
                    mass: 1,
                    shape: new CANNON.Sphere(0.5),
                    position: new CANNON.Vec3(0, 1.6, 0),
                    material: new CANNON.Material({ friction: 0.3 }),
                    collisionFilterGroup: COLLISION_GROUP_PLAYER,
                    collisionFilterMask: COLLISION_GROUP_OBJECT // Collide uniquement avec les objets
                });
                this.world.addBody(this.playerBody);

                // Variables de contr√¥le
                this.yaw = 0;
                this.pitch = 0;
                this.grabbedObject = null;
                this.grabbedMesh = null; // R√©f√©rence au maillage de l'objet grab√©

                // Initialisation des contr√¥les de la souris
                this.initMouseControls();

                // Ajout des √©couteurs de clic de souris pour le grab/ungrab
                this.initMouseClick();

                // Ajout d'un helper pour visualiser le corps physique du joueur
                this.addPlayerHelper();

                // Initialisation du son de d√©placement
                this.movementSound = new Audio('sounds/footsteps.mp3');
                this.movementSound.loop = true;
                this.isMovementSoundPlaying = false;
            }

            initMouseControls() {
                document.addEventListener('mousemove', (event) => {
                    if (document.pointerLockElement === this.renderer.domElement) {
                        this.yaw -= event.movementX * 0.002;
                        this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch - event.movementY * 0.002));
                        this.cameraGroup.rotation.y = this.yaw;
                        this.camera.rotation.x = this.pitch;
                    }
                });
            }

            initMouseClick() {
                document.addEventListener('mousedown', (event) => {
                    if (event.button === 0) { // Clic gauche
                        this.tryGrabObject();
                    } else if (event.button === 2) { // Clic droit
                        // Impl√©menter l'action sp√©cifique pour le clic droit si n√©cessaire
                        // Par exemple, lancer un objet ou une autre action
                        this.tryGrabObject(); // Exemple : utiliser le clic droit pour attraper
                    }
                });

                document.addEventListener('mouseup', (event) => {
                    if (event.button === 0 || event.button === 2) { // Clic gauche ou droit
                        this.ungrabObject();
                    }
                });

                // Emp√™cher le menu contextuel lors du clic droit
                document.addEventListener('contextmenu', (event) => {
                    event.preventDefault();
                });
            }

            addPlayerHelper() {
                // Cr√©er un helper pour visualiser le corps physique du joueur
                const sphereGeometry = new THREE.SphereGeometry(this.playerBody.shapes[0].radius, 16, 16);
                const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
                this.playerHelper = new THREE.Mesh(sphereGeometry, sphereMaterial);
                this.scene.add(this.playerHelper);
            }

            updatePlayerHelper() {
                if (this.playerHelper) {
                    this.playerHelper.position.copy(this.playerBody.position);
                }
            }

            update() {
                this.handleMovement();
                this.updateCameraPosition();

                // Mise √† jour du helper
                this.updatePlayerHelper();
            }

            handleMovement() {
                const direction = new THREE.Vector3(
                    (this.input.isKeyPressed('q') ? -1 : 0) + (this.input.isKeyPressed('d') ? 1 : 0),
                    0,
                    (this.input.isKeyPressed('z') ? -1 : 0) + (this.input.isKeyPressed('s') ? 1 : 0)
                ).applyAxisAngle(new THREE.Vector3(0, 1, 0), this.yaw);

                // Appliquer la v√©locit√© directement
                this.playerBody.velocity.x = direction.x * 2;
                this.playerBody.velocity.z = direction.z * 2;

                const isMoving = direction.length() > 0;
                if (isMoving && !this.isMovementSoundPlaying) {
                    this.movementSound.play();
                    this.isMovementSoundPlaying = true;
                } else if (!isMoving && this.isMovementSoundPlaying) {
                    this.movementSound.pause();
                    this.isMovementSoundPlaying = false;
                }
            }

            updateCameraPosition() {
                this.cameraGroup.position.copy(this.playerBody.position);
            }

            tryGrabObject() {
                if (this.grabbedObject) return; // D√©j√† un objet attrap√©

                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2(0, 0); // Centre de l'√©cran

                raycaster.setFromCamera(mouse, this.camera);
                raycaster.far = 2.5; // Limiter la distance de grab √† 2.5 unit√©s

                // Collecte de tous les maillages qui pourraient √™tre attrap√©s
                const objectsToIntersect = [];
                this.scene.traverse((child) => {
                    if (child.isMesh && child.userData && child.userData.body && child.userData.body.mass > 0) {
                        objectsToIntersect.push(child);
                    }
                });

                const intersects = raycaster.intersectObjects(objectsToIntersect, true);
                for (let intersect of intersects) {
                    const object = intersect.object;

                    if (object.userData && object.userData.body && object.userData.body.mass > 0) {
                        this.grabbedObject = object.userData.body;
                        this.grabbedMesh = object; // Stocker la r√©f√©rence au maillage

                        // D√©sactiver la physique de l'objet
                        this.disablePhysics(this.grabbedObject);

                        // Marquer l'objet comme attrap√©
                        if (this.grabbedMesh.userData.gameObject) {
                            this.grabbedMesh.userData.gameObject.grab();
                        }

                        // Attacher le maillage √† la cam√©ra
                        this.attachMeshToCamera(this.grabbedMesh);

                        break;
                    }
                }
            }

            ungrabObject() {
                if (!this.grabbedObject) return; // Aucun objet √† lib√©rer

                // D√©tacher le maillage de la cam√©ra
                this.detachMeshFromCamera(this.grabbedMesh);

                // R√©activer la physique de l'objet
                this.enablePhysics(this.grabbedObject);

                // Marquer l'objet comme lib√©r√©
                if (this.grabbedMesh.userData.gameObject) {
                    this.grabbedMesh.userData.gameObject.ungrab();
                }

                // R√©initialiser les r√©f√©rences
                this.grabbedObject = null;
                this.grabbedMesh = null;
            }

            disablePhysics(body) {
                // Enlever le corps du monde physique
                this.world.removeBody(body);
            }

            enablePhysics(body) {
                // R√©ajouter le corps au monde physique
                this.world.addBody(body);
                body.velocity.set(0, 0, 0); // R√©initialiser la v√©locit√©
                body.angularVelocity.set(0, 0, 0);
            }

            attachMeshToCamera(mesh) {
                // Positionner l'objet √† une distance fixe devant la cam√©ra
                const grabDistance = 1.5; // Distance devant la cam√©ra
                mesh.position.set(0, 0, -grabDistance);

                // D√©finir la rotation pour qu'elle soit align√©e avec la cam√©ra
                mesh.quaternion.set(0, 0, 0, 1);

                // Ajouter le maillage √† la cam√©ra pour qu'il suive automatiquement les mouvements de la cam√©ra
                this.camera.add(mesh);
            }

            detachMeshFromCamera(mesh) {
                // Mettre √† jour la position mondiale avant de d√©tacher
                mesh.updateMatrixWorld(true);

                // Obtenir la position mondiale du maillage
                const position = new THREE.Vector3();
                mesh.getWorldPosition(position);

                // Retirer le maillage de la cam√©ra et l'ajouter √† la sc√®ne
                this.camera.remove(mesh);
                this.scene.add(mesh);

                // Mettre √† jour la position du corps physique
                this.grabbedObject.position.set(position.x, position.y, position.z);

                // R√©orienter le corps physique pour correspondre √† la rotation du maillage
                const rotation = new THREE.Quaternion();
                mesh.getWorldQuaternion(rotation);
                this.grabbedObject.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
            }
        }

        // Classe principale du jeu
        class Game {
            constructor() {
                this.eventEmitter = new EventEmitter();
                this.sceneManager = new SceneManager();
                this.physicsManager = new PhysicsManager();
                this.inputManager = new InputManager();
                this.dynamicObjects = [];
                this.conveyorBelts = [];
                this.BinLid = null;
                this.debug = false;
                this.gameOver = false;
                this.gameStartTime = null;
                this.gameEndTime = null;

                this.initInstructions();
                this.initWorld();
                this.initSounds();
                this.player = new Player({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    renderer: this.sceneManager.renderer,
                    input: this.inputManager,
                    eventEmitter: this.eventEmitter
                });

                // G√©rer le redimensionnement de la fen√™tre
                window.addEventListener('resize', this.onWindowResize.bind(this));

                this.animate = this.animate.bind(this);

                // Param√®tres pour l'incr√©ment de la vitesse des tapis roulants
                this.conveyorSpeed = 0.5; // Vitesse initiale (units/s)

                // Initialiser le g√©n√©rateur de trays avec une intervalle initiale
                this.trayGenerationInterval = 4000; // Intervalle initial en ms

                // D√©finir la distance d√©sir√©e entre les plateaux en unit√©s
                const distanceDesiree = 1.5;

                // D√©finir l'incr√©ment de vitesse des tapis roulants
                const incrementVitesse = 0.2;

                // D√©finir la vitesse maximale des tapis roulants
                const vitesseMax = 4;

                // Initialiser la difficult√©
                this.difficulty = 0.3; // Niveau de difficult√© initial (0 = uniquement nourriture saine)

                // D√©finir l'incr√©ment de difficult√©
                const incrementDifficulty = 0.1; // Ajustement de la difficult√© √† chaque ex√©cution

                // max difficulty
                const maxDifficulty = 1;

                this.trayGenerator = new IntervalExecutor(() => {
                    new Tray({
                        scene: this.sceneManager.scene,
                        world: this.physicsManager.world,
                        game: this,
                        isDynamic: true,
                        transform: {
                            position: { x: -5, y: 1, z: -7 },
                            size: { x: 1.4, y: 0.05, z: 1 }
                        },
                        physics: {
                            mass: 1,
                            friction: 0.3,
                        },
                        appearance: {
                            color: 0xF1F1FF,
                            shapeType: 'box',
                            opacity: 1
                        },
                        collider: {
                            type: 'box',
                            size: { x: 1.4, y: 0.05, z: 1 }
                        }
                    });
                }, this.trayGenerationInterval);

                // Mettre √† jour la vitesse des tapis roulants et l'intervalle de g√©n√©ration des plateaux pour maintenir une distance constante
                new IntervalExecutor(() => {
                    // Augmenter la vitesse des tapis roulants
                    this.conveyorSpeed = Math.min(this.conveyorSpeed + incrementVitesse, vitesseMax);

                    // Mettre √† jour la vitesse de tous les tapis roulants
                    this.conveyorBelts.forEach(tapis => {
                        tapis.setSpeed(this.conveyorSpeed);
                    });

                    // Calculer le nouvel intervalle de g√©n√©ration des plateaux pour maintenir la distance d√©sir√©e
                    this.trayGenerationInterval = (distanceDesiree / this.conveyorSpeed) * 1000; // en ms

                    // Mettre √† jour l'intervalle du g√©n√©rateur de plateaux
                    this.trayGenerator.setIntervalTime(this.trayGenerationInterval);

                    // Augmenter progressivement la difficult√© jusqu'√† un maximum de 1
                    this.difficulty = Math.min(this.difficulty + incrementDifficulty, maxDifficulty);
                }, 15000);
            }

            initInstructions() {
                const instructions = document.getElementById('instructions');
                const startButton = document.getElementById('start-button');

                const startGame = () => {
                    this.sceneManager.renderer.domElement.requestPointerLock();
                    instructions.style.display = 'none';
                    this.gameStartTime = Date.now(); // Enregistrer le temps de d√©marrage
                };

                startButton.addEventListener('click', (event) => {
                    event.stopPropagation(); // Emp√™cher la propagation du clic au conteneur
                    startGame();
                });

                instructions.addEventListener('click', () => {
                    startGame();
                });

                // √âcouter les changements de Pointer Lock
                document.addEventListener('pointerlockchange', () => {
                    if (document.pointerLockElement !== this.sceneManager.renderer.domElement) {
                        instructions.style.display = 'flex';
                    }
                });

                // Optionnel : √âcouter les changements de visibilit√© de la page
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible' && document.pointerLockElement !== this.sceneManager.renderer.domElement) {
                        instructions.style.display = 'flex';
                    }
                });
            }


            gameOverFunction(hasWon) {
                if (this.gameOver) return; // Emp√™cher plusieurs d√©clenchements

                this.gameOver = true;
                this.gameEndTime = Date.now();
                const elapsedTime = Math.floor((this.gameEndTime - this.gameStartTime) / 1000); // Temps en secondes

                const gameOverScreen = document.getElementById('gameOverScreen');
                const gameOverEmoji = document.getElementById('gameOverEmoji');
                const gameOverMessage = document.getElementById('gameOverMessage');
                const gameOverTimer = document.getElementById('gameOverTimer');

                // D√©finir l'emoji et le message en fonction de la victoire ou de la d√©faite
                if (hasWon) {
                    gameOverEmoji.textContent = 'üèÜ'; // Emoji de victoire
                    gameOverMessage.textContent = 'Vous avez gagn√© !';
                } else {
                    gameOverEmoji.textContent = 'üíÄ'; // Emoji de d√©faite
                    gameOverMessage.textContent = 'Vous avez perdu !';
                }

                gameOverTimer.textContent = `Temps √©coul√© : ${elapsedTime} secondes`;

                // Afficher l'√©cran de fin de jeu
                gameOverScreen.style.display = 'flex';

                // Animer les √©l√©ments avec GSAP
                gsap.to('#gameOverEmoji', { duration: 1, opacity: 1, ease: "bounce.out" });
                gsap.to('#gameOverMessage', { duration: 1, opacity: 1, delay: 0.5 });
                gsap.to('#gameOverTimer', { duration: 1, opacity: 1, delay: 1 });
            }

            initWorld() {

                // Ajouter les murs, le sol et le plafond pour cr√©er une salle ferm√©e
                const wallThickness = 0.5;
                const floorThickness = wallThickness;
                const roomSize = { x: 12, y: 5, z: 15 };
                const roomCenter = { x: -0.5, y: 2, z: -2 };

                // Cr√©ation du sol
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: roomCenter.x,
                            y: roomCenter.y - roomSize.y / 2 + floorThickness / 2,
                            z: roomCenter.z
                        },
                        size: { x: roomSize.x, y: floorThickness, z: roomSize.z }
                    },
                    physics: {
                        mass: 0,
                        friction: 0.5
                    },
                    appearance: {
                        texture: 'textures/floor.jpg',
                        repeating: true,
                        repeatDimensions: { x: 2, y: 2 },
                        shapeType: 'box',
                        opacity: 1
                    },
                    collider: {
                        type: 'box',
                        size: { x: roomSize.x, y: floorThickness, z: roomSize.z }
                    }
                });

                // Mur arri√®re
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: roomCenter.x,
                            y: roomCenter.y,
                            z: roomCenter.z - roomSize.z / 2 - wallThickness / 2
                        },
                        size: { x: roomSize.x, y: roomSize.y, z: wallThickness }
                    },
                    physics: {
                        mass: 0
                    },
                    appearance: {
                        color: 0x9e9e9e,
                        shapeType: 'box'
                    },
                    collider: {
                        type: 'box',
                        size: { x: roomSize.x, y: roomSize.y, z: wallThickness }
                    }
                });

                // Mur avant
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: roomCenter.x,
                            y: roomCenter.y,
                            z: roomCenter.z + roomSize.z / 2 + wallThickness / 2
                        },
                        size: { x: roomSize.x, y: roomSize.y, z: wallThickness }
                    },
                    physics: {
                        mass: 0
                    },
                    appearance: {
                        color: 0x5e5e5e,
                        shapeType: 'box'
                    },
                    collider: {
                        type: 'box',
                        size: { x: roomSize.x, y: roomSize.y, z: wallThickness }
                    }
                });

                // Mur gauche
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: roomCenter.x - roomSize.x / 2 - wallThickness / 2,
                            y: roomCenter.y,
                            z: roomCenter.z
                        },
                        size: { x: wallThickness, y: roomSize.y, z: roomSize.z }
                    },
                    physics: {
                        mass: 0
                    },
                    appearance: {
                        color: 0x5e5e5e,
                        shapeType: 'box'
                    },
                    collider: {
                        type: 'box',
                        size: { x: wallThickness, y: roomSize.y, z: roomSize.z }
                    }
                });

                // Mur droit
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: roomCenter.x + roomSize.x / 2 + wallThickness / 2,
                            y: roomCenter.y,
                            z: roomCenter.z
                        },
                        size: { x: wallThickness, y: roomSize.y, z: roomSize.z }
                    },
                    physics: {
                        mass: 0
                    },
                    appearance: {
                        color: 0x5e5e5e,
                        shapeType: 'box'
                    },
                    collider: {
                        type: 'box',
                        size: { x: wallThickness, y: roomSize.y, z: roomSize.z }
                    }
                });

                // Plafond
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: roomCenter.x,
                            y: roomCenter.y + roomSize.y / 2 - floorThickness / 2,
                            z: roomCenter.z
                        },
                        size: { x: roomSize.x, y: floorThickness, z: roomSize.z }
                    },
                    physics: {
                        mass: 0
                    },
                    appearance: {
                        color: 0xcccccc,
                        shapeType: 'box'
                    },
                    collider: {
                        type: 'box',
                        size: { x: roomSize.x, y: floorThickness, z: roomSize.z }
                    }
                });

                // Front wall window
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: 5,
                            y: 0.2,
                            z: 5.4
                        },
                        size: { x: 2, y: 2, z: 0.1 }
                    },
                    model: {
                        path: 'models/environments/window.glb'
                    }
                });

                // Right wall window
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: -6.5,
                            y: 0.2,
                            z: -7
                        },
                        size: { x: 2, y: 2, z: 0.1 },
                        rotation: { x: 0, y: Math.PI / 2, z: 0 }
                    },
                    model: {
                        path: 'models/environments/window.glb'
                    }
                });

                // Back wall door
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: {
                            x: roomCenter.x,
                            y: -0.1,
                            z: -9.69
                        },
                        size: { x: 1, y: 2, z: 0.1 }
                    },
                    model: {
                        path: 'models/environments/door.glb'
                    }
                });

                // light
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: { x: -0.5, y: 3.4, z: -2 },
                        size: { x: 1, y: 2, z: 0.1 }
                    },
                    model: {
                        path: 'models/environments/light.glb'
                    }
                });

                // Cr√©ation d'un plateau r√©cepteur
                new TrayReceptor({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    isDynamic: true,
                    transform: {
                        position: { x: 4, y: 1.5, z: -9.4 },
                        size: { x: 0.1, y: 2, z: 2 },
                        rotation: { x: 0, y: Math.PI / 2, z: 0 }
                    },
                    physics: {
                        mass: 0
                    },
                    appearance: {
                        color: 0x000000, // Vert
                        shapeType: 'box',
                        opacity: 1
                    },
                    collider: {
                        type: 'box',
                        size: { x: 0.1, y: 2, z: 2 },
                    }
                });
                // Couvercle de la poubelle
                this.BinLid = new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: { x: -0.5, y: 1.60, z: -1.97 },
                        size: { x: 1.2, y: 0.05, z: 0.7 },
                        rotation: { x: 0, y: 0, z: 0 }
                    },
                    appearance: {
                        color: 0x969696,
                        shapeType: 'box',
                        opacity: 1
                    },
                });
                // Cr√©ation d'une poubelle
                new Bin({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    isDynamic: true,
                    transform: {
                        position: { x: -0.5, y: 0.75, z: -2 },
                        size: { x: 1, y: 1.5, z: 0.5 },
                        rotation: { x: 0, y: 0, z: 0 }
                    },
                    physics: {
                        mass: 0
                    },
                    model: {
                        path: 'models/environments/trash.glb'
                    },
                    collider: {
                        type: 'box',
                        size: { x: 1, y: 1.5, z: 0.5 }
                    }
                });

                // Tapis roulant du c√¥t√© gauche du U
                const conveyorBelt1 = new ConveyorBelt({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    isDynamic: true,
                    transform: {
                        position: { x: -5, y: 0.5, z: -2.5 }, // Position d√©cal√©e √† gauche
                        rotation: { x: 0, y: -Math.PI / 2, z: 0 }, // Orientation verticale
                        size: { x: 10, y: 1.5, z: 2 } // Taille du tapis
                    },
                    appearance: {
                        color: 0x000000,
                        opacity: 1,
                        shapeType: 'box'
                    },
                    physics: {
                        mass: 0,
                        friction: 0,
                    },
                    collider: {
                        type: 'box',
                        size: { x: 10, y: 1.5, z: 2 }
                    },
                    speed: this.conveyorSpeed,
                });

                const conveyorBelt2 = new ConveyorBelt({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    isDynamic: true,
                    transform: {
                        position: { x: -1, y: 0.499, z: 3 }, // Position centrale
                        size: { x: 10, y: 1.5, z: 2 },    // Taille du tapis
                        rotation: { x: 0, y: 0, z: 0 }   // Orientation horizontale
                    },
                    appearance: {
                        color: 0x000000,
                        opacity: 1,
                        shapeType: 'box'
                    },
                    physics: {
                        mass: 0,
                        friction: 0,
                    },
                    collider: {
                        type: 'box',
                        size: { x: 10, y: 1.5, z: 2 }
                    },
                    speed: this.conveyorSpeed,
                });

                const conveyorBelt3 = new ConveyorBelt({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    isDynamic: true,
                    transform: {
                        position: { x: 4, y: 0.498, z: -3 }, // Position d√©cal√©e √† gauche
                        size: { x: 14, y: 1.5, z: 2 },        // Taille du tapis
                        rotation: { x: 0, y: Math.PI / 2, z: 0 } // Orientation verticale
                    },
                    appearance: {
                        color: 0x000000,
                        opacity: 1,
                        shapeType: 'box'
                    },
                    physics: {
                        mass: 0,
                        friction: 0,
                    },
                    collider: {
                        type: 'box',
                        size: { x: 14, y: 1.5, z: 2 },        // Taille du tapis
                    },
                    speed: this.conveyorSpeed,
                });

                this.conveyorBelts.push(conveyorBelt1, conveyorBelt2, conveyorBelt3);

                // Cr√©ation d'un d√©cor de tapis roulant du c√¥t√© gauche du U
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: { x: 4, y: 0.3, z: -2.5 },
                        size: { x: 1.4, y: 1.5, z: 2 },
                        rotation: { x: 0, y: Math.PI / 2, z: 0 }
                    },
                    model: {
                        path: 'models/environments/conveyor.glb'
                    }
                });

                // Cr√©ation d'un d√©cor de tapis roulant du cot√© droit du U
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: { x: -5, y: 0.3, z: -2.5 },
                        size: { x: 1.4, y: 1.5, z: 2 },
                        rotation: { x: 0, y: Math.PI / 2, z: 0 }
                    },
                    model: {
                        path: 'models/environments/conveyor.glb'
                    }
                });

                // Cr√©ation d'un d√©cor de tapis roulant de la base du U
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: { x: -0.5, y: 0.3, z: 3 },
                        size: { x: 1.4, y: 1.5, z: 2 },
                        rotation: { x: 0, y: 0, z: 0 }
                    },
                    model: {
                        path: 'models/environments/conveyor2.glb'
                    }
                });

                // Decor plateau g√©n√©rateur
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: { x: -5, y: -0.2, z: -6.90 },
                        size: { x: 1.4, y: 1.5, z: 2 },
                        rotation: { x: 0, y: Math.PI / 2, z: Math.PI / 2 }
                    },
                    model: {
                        path: 'models/environments/conveyor_hole.glb'
                    }
                });

                // D√©cor plateau r√©cepteur
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: { x: 4, y: 1.8, z: -9 },
                        size: { x: 1.4, y: 1.5, z: 2 },
                        rotation: { x: 0, y: Math.PI / 2, z: 0 }
                    },
                    model: {
                        path: 'models/environments/conveyor_hole.glb'
                    }
                });
            }

            initSounds() {
                var audio = new Audio('sounds/conveyor.mp3');
                audio.volume = 0.06;
                audio.loop = true;
                audio.play();
            }

            animate() {
                requestAnimationFrame(this.animate);

                // Mettre √† jour la physique
                this.physicsManager.step();

                // Mettre √† jour tous les objets dynamiques
                this.dynamicObjects.forEach(obj => obj.update());

                // Mettre √† jour le joueur
                this.player.update();

                // Rendu de la sc√®ne avec la cam√©ra du joueur
                this.sceneManager.render(this.player.camera);
            }

            start() {
                this.animate();
            }

            onWindowResize() {
                this.player.camera.aspect = window.innerWidth / window.innerHeight;
                this.player.camera.updateProjectionMatrix();
                this.sceneManager.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Initialisation du jeu
        const game = new Game();
        game.start();
    </script>
</body>

</html>
