<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title>Jeu 3D avec Three.js et Cannon.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #instructions {
            position: absolute;
            top: 50%;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            user-select: none;
            cursor: pointer;
            z-index: 1000;
        }

        /* Style du crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            margin-left: -5px;
            /* Pour centrer horizontalement */
            margin-top: -5px;
            /* Pour centrer verticalement */
            background-color: white;
            border: 2px solid black;
            border-radius: 50%;
            pointer-events: none;
            /* Permet de cliquer à travers le crosshair */
            z-index: 1000;
        }
    </style>
</head>

<body>
    <div id="instructions">Cliquez pour démarrer</div>
    <div id="crosshair"></div> <!-- Ajout du crosshair -->
    <div id="unhealthyCount" style="position: absolute; top: 10px; left: 10px; color: white; font-family: Arial, sans-serif; z-index: 1000;">Unhealthy Count: 0</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // Pour pas oublier, il faut que je crée un générateur de plateau et. Et ensuite ? Ensuite Une classe générateur de plateau on. Ensuite, il faut que je fasse en sorte que les choses qui peuvent être upgradeable sont la distance pour attraper un objet et aussi. Il faut savoir que en fait, les plateaux auront un indice de mauvaise bouffe et plus on avance Plus les plateaux auront condense à être dans la mauvaise bouffe et avoir un indice élevé de mauvaise bouffe. Et du coup, le joueur devra essayer de de vu qu'il pourra pas attraper tous les plateaux, il devra attraper les plateaux qu'ils ont le plus gros indice de mauvaise bouffe. Ensuite  La vitesse de déplacement sera aussi un élément qui sera upgradable
        // Définir les groupes de collision
        const COLLISION_GROUP_PLAYER = 1 << 0; // 1
        const COLLISION_GROUP_OBJECT = 1 << 1; // 2

        // Gestionnaire des événements
        class EventEmitter {
            constructor() {
                this.events = {};
            }

            on(event, listener) {
                if (!this.events[event]) {
                    this.events[event] = [];
                }
                this.events[event].push(listener);
            }

            emit(event, data) {
                if (this.events[event]) {
                    this.events[event].forEach(listener => listener(data));
                }
            }
        }

        // Gestionnaire de la scène Three.js
        class SceneManager {
            constructor() {
                this.scene = new THREE.Scene();
                // Ajout d'une lumière directionnelle pour mieux voir les objets
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(5, 10, 7.5);
                this.scene.add(light);

                // Ajout d'une lumière ambiante
                const ambientLight = new THREE.AmbientLight(0x404040); // lumière douce
                this.scene.add(ambientLight);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement);
            }

            render(camera) {
                this.renderer.render(this.scene, camera);
            }
        }

        // Gestionnaire de la physique Cannon.js
        class PhysicsManager {
            constructor() {
                this.world = new CANNON.World();
                this.world.gravity.set(0, -9.82, 0);
                this.fixedTimeStep = 1 / 60;
                this.maxSubSteps = 3;
            }

            step() {
                this.world.step(this.fixedTimeStep, undefined, this.maxSubSteps);
            }
        }

        // Gestionnaire des entrées utilisateur
        class InputManager {
            constructor() {
                this.keys = {};
                this.listeners = {};

                this.initControls();
            }

            initControls() {
                document.addEventListener('keydown', (e) => this.onKeyChange(e, true));
                document.addEventListener('keyup', (e) => this.onKeyChange(e, false));
            }

            onKeyChange(event, isPressed) {
                const key = event.key.toLowerCase();
                this.keys[key] = isPressed;

                if (this.listeners[key]) {
                    this.listeners[key].forEach(callback => callback(isPressed));
                }
            }

            bindKey(key, callback) {
                key = key.toLowerCase();
                if (!this.listeners[key]) {
                    this.listeners[key] = [];
                }
                this.listeners[key].push(callback);
            }

            isKeyPressed(key) {
                return !!this.keys[key.toLowerCase()];
            }
        }

        // Classe représentant un objet du jeu
        class GameObject {
            constructor(options) {
                this.scene = options.scene;
                this.world = options.world;
                this.game = options.game;

                // Fusion des options avec les valeurs par défaut
                const defaultTransform = {
                    position: { x: 0, y: 0, z: 0 },
                    rotation: { x: 0, y: 0, z: 0 },
                    size: { x: 1, y: 1, z: 1 }
                };
                const defaultPhysics = { mass: 0, friction: 0.3 };
                const defaultAppearance = { color: 0x808080, opacity: 1, texturePath: null, shapeType: 'box' };

                const defaultModel = { path: null };
                const defaultCollider = { type: 'box', size: { x: 1, y: 1, z: 1 } };
                const defaultIsDynamic = false;

                this.transform = Object.assign({}, defaultTransform, options.transform);
                this.transform.position = Object.assign({}, defaultTransform.position, options.transform?.position);
                this.transform.rotation = Object.assign({}, defaultTransform.rotation, options.transform?.rotation);
                this.transform.size = Object.assign({}, defaultTransform.size, options.transform?.size);

                this.physics = Object.assign({}, defaultPhysics, options.physics);
                this.appearance = Object.assign({}, defaultAppearance, options.appearance);
                this.model = Object.assign({}, defaultModel, options.model);
                this.collider = Object.assign({}, defaultCollider, options.collider);
                this.isDynamic = Object.assign({}, defaultIsDynamic, options.isDynamic);

                // Configuration physique avec groupes de collision
                this.body = new CANNON.Body({
                    mass: this.physics.mass,
                    position: new CANNON.Vec3(this.transform.position.x, this.transform.position.y, this.transform.position.z),
                    material: new CANNON.Material({ friction: this.physics.friction }),
                    quaternion: new CANNON.Quaternion().setFromEuler(this.transform.rotation.x, this.transform.rotation.y, this.transform.rotation.z, 'XYZ'),
                    collisionFilterGroup: COLLISION_GROUP_OBJECT,
                    collisionFilterMask: COLLISION_GROUP_PLAYER | COLLISION_GROUP_OBJECT // Collide avec le joueur et les autres objets
                });                // Apply initial rotation to the physics body

                // Définir la forme de collision
                this.setCollider();

                // Ajouter le corps physique au monde
                this.world.addBody(this.body);

                // Charger ou créer le modèle visuel
                this.initVisual();

                // Ajouter l'objet aux objets dynamiques de la scène
                if (this.isDynamic) {
                    options.game.dynamicObjects.push(this);
                }

                // Indique si l'objet est actuellement attrapé
                this.isGrabbed = false;
            }

            setCollider() {
                const { type, size } = this.collider;
                let shape;
                switch (type) {
                    case 'sphere':
                        shape = new CANNON.Sphere(size.x / 2);
                        break;
                    case 'cylinder':
                        shape = new CANNON.Cylinder(size.x / 2, size.x / 2, size.y, 12);
                        break;
                    case 'box':
                    default:
                        shape = new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));
                }
                this.body.addShape(shape);
            }

            initVisual() {
                const { color, opacity, texturePath, shapeType } = this.appearance;
                const { size, rotation, position } = this.transform;

                // Création du matériau
                const materialOptions = {
                    color: color,
                    transparent: opacity < 1,
                    opacity: opacity
                };
                if (texturePath) {
                    const textureLoader = new THREE.TextureLoader();
                    materialOptions.map = textureLoader.load(texturePath);
                }
                const material = new THREE.MeshStandardMaterial(materialOptions);

                // Création du maillage
                if (this.model.path) {
                    const loader = new THREE.GLTFLoader();
                    loader.load(this.model.path, (gltf) => {
                        this.mesh = gltf.scene;
                        this.mesh.userData.gameObject = this; // Ajout de la référence à GameObject
                        this.applyTransformations();
                        this.scene.add(this.mesh);

                        // Associer le corps physique à tous les maillages enfants
                        this.mesh.traverse((child) => {
                            if (child.isMesh) {
                                child.userData.body = this.body;
                            }
                        });

                        // Ajout d'un helper pour visualiser le collider
                        this.addColliderHelper();
                    });
                } else {
                    this.createDefaultMesh(shapeType, material, size);
                }
            }

            createDefaultMesh(shapeType, material, size) {
                switch (shapeType) {
                    case 'sphere':
                        this.mesh = new THREE.Mesh(new THREE.SphereGeometry(size.x / 2, 32, 32), material);
                        break;
                    case 'cylinder':
                        this.mesh = new THREE.Mesh(new THREE.CylinderGeometry(size.x / 2, size.x / 2, size.y, 12), material);
                        break;
                    case 'box':
                    default:
                        this.mesh = new THREE.Mesh(new THREE.BoxGeometry(size.x, size.y, size.z), material);
                }
                this.mesh.userData.gameObject = this; // Ajout de la référence à GameObject
                this.applyTransformations();
                this.scene.add(this.mesh);

                // Associer le corps physique au maillage pour permettre la récupération dans Player
                this.mesh.userData.body = this.body;

                // Ajout d'un helper pour visualiser le collider
                this.addColliderHelper();
            }

            applyTransformations() {
                if (this.mesh && this.body) {
                    this.mesh.position.copy(this.body.position);
                    this.mesh.quaternion.copy(this.body.quaternion);
                }
            }

            addColliderHelper() {
                // Créer un helper pour visualiser le collider basé sur la forme physique
                let geometry;
                const shape = this.body.shapes[0];
                switch (shape.type) {
                    case CANNON.Shape.types.BOX:
                        const halfExtents = shape.halfExtents;
                        geometry = new THREE.BoxGeometry(halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2);
                        break;
                    case CANNON.Shape.types.SPHERE:
                        const radius = shape.radius;
                        geometry = new THREE.SphereGeometry(radius, 16, 16);
                        break;
                    case CANNON.Shape.types.CYLINDER:
                        const radiusTop = shape.radiusTop;
                        const radiusBottom = shape.radiusBottom;
                        const height = shape.height;
                        geometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, 16);
                        break;
                    // Ajoutez d'autres types de formes si nécessaire
                    default:
                        console.warn('Type de forme non reconnu pour la visualisation du collider.');
                        return;
                }
                const material = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
                const helper = new THREE.Mesh(geometry, material);
                helper.name = 'ColliderHelper';
                this.scene.add(helper);

                // Initialiser la position et la rotation du helper
                helper.position.copy(this.body.position);
                helper.quaternion.copy(this.body.quaternion);

                // Mettre à jour le helper uniquement si l'objet est dynamique
                if (this.body.mass > 0) {
                    this.updateColliderHelper = () => {
                        helper.position.copy(this.body.position);
                        helper.quaternion.copy(this.body.quaternion);
                    };
                }
            }

            grab() {
                this.isGrabbed = true;
            }

            ungrab() {
                this.isGrabbed = false;
            }

            update() {
                if (this.isGrabbed) return; // Ne pas mettre à jour si l'objet est attrapé

                if (this.body.mass > 0 && this.mesh) {
                    this.mesh.position.copy(this.body.position);
                    this.mesh.quaternion.copy(this.body.quaternion);
                    if (this.updateColliderHelper) {
                        this.updateColliderHelper();
                    }
                }
            }
        }

        // Mise à jour de la classe Tray pour charger des modèles GLB de nourriture dynamiquement
        class Tray extends GameObject {
            constructor(options) {
                super(options);
                this.type = 'tray'; // Définir le type plateau
                this.UnhealthyCount = 0; // Compteur de malbouffe
                this.healthyFoodModels = [
                    'models/soda.glb',
                    'models/test.glb',
                    // Ajoutez les chemins vers vos modèles de nourriture saine ici
                ];

                this.unhealthyFoodModels = [
                    'models/burger.glb',
                    'models/hotdog.glb',
                    // Ajoutez les chemins vers vos modèles de nourriture non saine ici
                ];

                this.foodModels = [...this.healthyFoodModels, ...this.unhealthyFoodModels];
                this.initFood();
            }

            initFood() {
                const positions = [
                    { x: -0.5, y: 0.05, z: -0.3 },
                    { x: 0, y: 0.05, z: -0.3 },
                    { x: 0.5, y: 0.05, z: -0.3 },
                    { x: -0.5, y: 0.05, z: 0.3 },
                    { x: 0, y: 0.05, z: 0.3 },
                    { x: 0.5, y: 0.05, z: 0.3 }
                ];

                const loader = new THREE.GLTFLoader();
                const count = Math.floor(Math.random() * 6) + 1;
                const shuffled = positions.sort(() => 0.5 - Math.random()).slice(0, count);

                shuffled.forEach(position => {
                    const modelPath = this.foodModels[Math.floor(Math.random() * this.foodModels.length)];

                    const isUnhealthy = this.unhealthyFoodModels.includes(modelPath);
                    if (isUnhealthy) {
                        this.UnhealthyCount += 1;
                    }

                    loader.load(modelPath, gltf => {
                        const food = gltf.scene;
                        food.position.set(position.x, position.y, position.z);
                        this.mesh.add(food);
                    });
                });
            }
        }

        class TrayReceptor extends GameObject {
            constructor(options) {
                super(options);
            }

            update() {
                this.game.dynamicObjects.forEach(obj => {
                    const body = obj.body;
                    if (this.isInContact(body)) {
                        document.getElementById('unhealthyCount').textContent = `Unhealthy Count: ${this.game.player.UnhealthyCount}`;
                        //verifier si l'objet est de type tray et si oui, recuperer la variable de malbouffe et detruire le tray
                        if (obj.type === 'tray') {
                            // Detruire le tray
                            this.scene.remove(obj.mesh);
                            this.world.removeBody(obj.body);
                            // Ajouter la variable de malbouffe au joueur
                            this.game.player.UnhealthyCount += obj.UnhealthyCount;
                        }
                    }
                });
                super.update();
            }

            isInContact(body) {
                return this.world.contacts.some(contact => {
                    return (
                        (contact.bi === this.body && contact.bj === body) ||
                        (contact.bj === this.body && contact.bi === body)
                    );
                });
            }
        }  

        class ConveyorBelt extends GameObject {
            constructor(options) {
                super(options);

                this.speed = options.speed || 0.5;

                // Définir la rotation initiale
                const rotation = options.transform.rotation || new THREE.Vector3(0, 0, 0);
                const euler = new THREE.Euler(rotation.x, rotation.y, rotation.z, 'XYZ');

                // Calculer la direction basée sur la rotation initiale
                this.direction = new THREE.Vector3(1, 0, 0).applyEuler(euler).normalize();
            }

            update() {
                this.game.dynamicObjects.forEach(obj => {
                    const body = obj.body;
                    if (this.isInContact(body)) {
                        // Appliquer la vélocité en fonction de la direction fixe
                        body.velocity.set(
                            this.direction.x * this.speed,
                            body.velocity.y,
                            this.direction.z * this.speed
                        );
                    }
                });
                super.update();
            }

            isInContact(body) {
                return this.world.contacts.some(contact => {
                    return (
                        (contact.bi === this.body && contact.bj === body) ||
                        (contact.bj === this.body && contact.bi === body)
                    );
                });
            }
        }

        class IntervalExecutor {
            constructor(callback, interval) {
                this.callback = callback;
                this.interval = interval;
                this.timerId = null;
                this.start();
            }

            start() {
                this.stop(); // Ensure no multiple timers
                this.timerId = setInterval(this.callback, this.interval);
            }

            stop() {
                if (this.timerId !== null) {
                    clearInterval(this.timerId);
                    this.timerId = null;
                }
            }

            setIntervalTime(newInterval) {
                this.interval = newInterval;
                this.start();
            }
        }

        // Classe représentant le joueur
        class Player {
            constructor(options) {
                this.scene = options.scene;
                this.world = options.world;
                this.renderer = options.renderer;
                this.input = options.input;
                this.eventEmitter = options.eventEmitter;
                this.cameraGroup = new THREE.Group();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.y = 1.6;
                this.cameraGroup.add(this.camera);
                this.scene.add(this.cameraGroup);

                // Initialiser le joueur
                this.UnhealthyCount = 0;

                // Corps physique du joueur
                this.playerBody = new CANNON.Body({
                    mass: 1,
                    shape: new CANNON.Sphere(0.5),
                    position: new CANNON.Vec3(0, 1.6, 0),
                    material: new CANNON.Material({ friction: 0.3 }),
                    collisionFilterGroup: COLLISION_GROUP_PLAYER,
                    collisionFilterMask: COLLISION_GROUP_OBJECT // Collide uniquement avec les objets
                });
                this.world.addBody(this.playerBody);

                // Variables de contrôle
                this.yaw = 0;
                this.pitch = 0;
                this.grabbedObject = null;
                this.grabbedMesh = null; // Référence au maillage de l'objet grabé

                // Initialisation des contrôles de la souris
                this.initMouseControls();

                // Ajout des écouteurs de clic de souris pour le grab/ungrab
                this.initMouseClick();

                // Ajout d'un helper pour visualiser le corps physique du joueur
                this.addPlayerHelper();
            }

            initMouseControls() {
                document.addEventListener('mousemove', (event) => {
                    if (document.pointerLockElement === this.renderer.domElement) {
                        this.yaw -= event.movementX * 0.002;
                        this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch - event.movementY * 0.002));
                        this.cameraGroup.rotation.y = this.yaw;
                        this.camera.rotation.x = this.pitch;
                    }
                });
            }

            initMouseClick() {
                document.addEventListener('mousedown', (event) => {
                    if (event.button === 0) { // Clic gauche
                        this.tryGrabObject();
                    }
                });

                document.addEventListener('mouseup', (event) => {
                    if (event.button === 0) { // Clic gauche
                        this.ungrabObject();
                    }
                });
            }

            addPlayerHelper() {
                // Créer un helper pour visualiser le corps physique du joueur
                const sphereGeometry = new THREE.SphereGeometry(this.playerBody.shapes[0].radius, 16, 16);
                const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
                this.playerHelper = new THREE.Mesh(sphereGeometry, sphereMaterial);
                this.scene.add(this.playerHelper);
            }

            updatePlayerHelper() {
                if (this.playerHelper) {
                    this.playerHelper.position.copy(this.playerBody.position);
                }
            }

            update() {
                this.handleMovement();
                this.updateCameraPosition();

                // Mise à jour du helper
                this.updatePlayerHelper();
            }

            handleMovement() {
                const direction = new THREE.Vector3(
                    (this.input.isKeyPressed('q') ? -1 : 0) + (this.input.isKeyPressed('d') ? 1 : 0),
                    0,
                    (this.input.isKeyPressed('z') ? -1 : 0) + (this.input.isKeyPressed('s') ? 1 : 0)
                ).applyAxisAngle(new THREE.Vector3(0, 1, 0), this.yaw);

                // Appliquer la vélocité directement
                this.playerBody.velocity.x = direction.x * 5;
                this.playerBody.velocity.z = direction.z * 5;
            }

            updateCameraPosition() {
                this.cameraGroup.position.copy(this.playerBody.position);
            }

            tryGrabObject() {
                if (this.grabbedObject) return; // Déjà un objet attrapé

                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2(0, 0); // Centre de l'écran

                raycaster.setFromCamera(mouse, this.camera);

                // Collecte de tous les maillages qui pourraient être attrapés
                const objectsToIntersect = [];
                this.scene.traverse((child) => {
                    if (child.isMesh && child.userData && child.userData.body && child.userData.body.mass > 0) {
                        objectsToIntersect.push(child);
                    }
                });

                const intersects = raycaster.intersectObjects(objectsToIntersect, true);
                for (let intersect of intersects) {
                    const object = intersect.object;

                    if (object.userData && object.userData.body && object.userData.body.mass > 0) {
                        this.grabbedObject = object.userData.body;
                        this.grabbedMesh = object; // Stocker la référence au maillage

                        // Désactiver la physique de l'objet
                        this.disablePhysics(this.grabbedObject);

                        // Marquer l'objet comme attrapé
                        if (this.grabbedMesh.userData.gameObject) {
                            this.grabbedMesh.userData.gameObject.grab();
                        }

                        // Attacher le maillage à la caméra
                        this.attachMeshToCamera(this.grabbedMesh);

                        console.log('Objet attrapé:', object);
                        break;
                    }
                }
            }

            ungrabObject() {
                if (!this.grabbedObject) return; // Aucun objet à libérer

                // Détacher le maillage de la caméra
                this.detachMeshFromCamera(this.grabbedMesh);

                // Réactiver la physique de l'objet
                this.enablePhysics(this.grabbedObject);

                // Marquer l'objet comme libéré
                if (this.grabbedMesh.userData.gameObject) {
                    this.grabbedMesh.userData.gameObject.ungrab();
                }

                console.log('Objet libéré');

                // Réinitialiser les références
                this.grabbedObject = null;
                this.grabbedMesh = null;
            }

            disablePhysics(body) {
                // Enlever le corps du monde physique
                this.world.removeBody(body);
            }

            enablePhysics(body) {
                // Réajouter le corps au monde physique
                this.world.addBody(body);
                body.velocity.set(0, 0, 0); // Réinitialiser la vélocité
                body.angularVelocity.set(0, 0, 0);
            }

            attachMeshToCamera(mesh) {
                // Positionner l'objet à une distance fixe devant la caméra
                const grabDistance = 1.5; // Distance devant la caméra
                mesh.position.set(0, 0, -grabDistance);

                // Définir la rotation pour qu'elle soit alignée avec la caméra
                mesh.quaternion.set(0, 0, 0, 1);

                // Ajouter le maillage à la caméra pour qu'il suive automatiquement les mouvements de la caméra
                this.camera.add(mesh);
            }

            detachMeshFromCamera(mesh) {
                // Mettre à jour la position mondiale avant de détacher
                mesh.updateMatrixWorld(true);

                // Obtenir la position mondiale du maillage
                const position = new THREE.Vector3();
                mesh.getWorldPosition(position);

                // Retirer le maillage de la caméra et l'ajouter à la scène
                this.camera.remove(mesh);
                this.scene.add(mesh);

                // Mettre à jour la position du corps physique
                this.grabbedObject.position.set(position.x, position.y, position.z);

                // Réorienter le corps physique pour correspondre à la rotation du maillage
                const rotation = new THREE.Quaternion();
                mesh.getWorldQuaternion(rotation);
                this.grabbedObject.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
            }
        }

        // Classe principale du jeu
        class Game {
            constructor() {
                this.eventEmitter = new EventEmitter();
                this.sceneManager = new SceneManager();
                this.physicsManager = new PhysicsManager();
                this.inputManager = new InputManager();
                this.dynamicObjects = [];

                this.initInstructions();
                this.initWorld();
                this.player = new Player({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    renderer: this.sceneManager.renderer,
                    input: this.inputManager,
                    eventEmitter: this.eventEmitter
                });

                // Gérer le redimensionnement de la fenêtre
                window.addEventListener('resize', this.onWindowResize.bind(this));

                this.animate = this.animate.bind(this);
            }

            initInstructions() {
                const instructions = document.getElementById('instructions');
                instructions.addEventListener('click', () => {
                    this.sceneManager.renderer.domElement.requestPointerLock();
                    instructions.style.display = 'none';
                });
            }

            initWorld() {
                // Création du sol
                new GameObject({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    transform: {
                        position: { x: 0, y: -0.5, z: 0 },
                        size: { x: 40, y: 1, z: 40 }
                    },
                    physics: {
                        mass: 0,
                        friction: 0.5,
                        restitution: 0.3
                    },
                    appearance: {
                        color: 0x00008B, // Bleu foncé
                        shapeType: 'box',
                        opacity: 1
                    },
                    collider: {
                        type: 'box',
                        size: { x: 40, y: 1, z: 40 }
                    }
                });

                // Création d'un cube dynamique
                new TrayReceptor({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    isDynamic: true,
                    transform: {
                        position: { x: 4, y: 0.5, z: -7.7 },
                        size: { x: 1.4, y: 1.5, z: 2},
                        rotation: { x: 0, y: Math.PI / 2, z: 0 }
                    },
                    physics: {
                        mass: 0,
                        friction: 0.3,
                        restitution: 0.6
                    },
                    appearance: {
                        color: 0x00FF00, // Vert
                        shapeType: 'box',
                        opacity: 1
                    },
                    collider: {
                        type: 'box',
                        size: { x: 1.4, y: 1.5, z: 2}
                    }
                });

                new IntervalExecutor(() => {
                    new Tray({
                        scene: this.sceneManager.scene,
                        world: this.physicsManager.world,
                        game: this,
                        IsDynamic: true,
                        transform: {
                            position: { x: -5, y: 1, z: -7 },
                            size: { x: 1.4, y: 0.1, z: 1 }
                        },
                        physics: {
                            mass: 1,
                            friction: 0.2,
                        },
                        appearance: {
                            color: 0xad8003,
                            shapeType: 'box',
                            opacity: 1
                        },
                        collider: {
                            type: 'box',
                            size: { x: 1.4, y: 0.1, z: 1 }
                        }
                    });
                }, 1000);

                // Tapis roulant du côté gauche du U
                new ConveyorBelt({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    IsDynamic: true,
                    transform: {
                        position: { x: -5, y: 0.5, z: -2.5 }, // Position décalée à gauche
                        size: { x: 10, y: 1.5, z: 2 },        // Taille du tapis
                        rotation: { x: 0, y: -Math.PI / 2, z: 0 } // Orientation verticale
                    },
                    physics: {
                        mass: 0,
                        friction: 0,
                        restitution: 0
                    },
                    appearance: {
                        color: 0x00FF00, // Vert
                        shapeType: 'box',
                        opacity: 1
                    },
                    collider: {
                        type: 'box',
                        size: { x: 10, y: 1.5, z: 2 }
                    },
                    speed: 1,
                });

                // Tapis roulant de la base du U
                new ConveyorBelt({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    IsDynamic: true,
                    transform: {
                        position: { x: -1, y: 0.499, z: 3 }, // Position centrale
                        size: { x: 10, y: 1.5, z: 2 },    // Taille du tapis
                        rotation: { x: 0, y: 0, z: 0 }   // Orientation horizontale
                    },
                    physics: {
                        mass: 0,
                        friction: 0,
                        restitution: 0
                    },
                    appearance: {
                        color: 0x00FF00, // Vert
                        shapeType: 'box',
                        opacity: 1
                    },
                    collider: {
                        type: 'box',
                        size: { x: 10, y: 1.5, z: 2 }
                    },
                    speed: 1,
                });

                // Tapis roulant du côté droit du U
                // Tapis roulant du côté gauche du U
                new ConveyorBelt({
                    scene: this.sceneManager.scene,
                    world: this.physicsManager.world,
                    game: this,
                    IsDynamic: true,
                    transform: {
                        position: { x: 4, y: 0.498, z: -1.5 }, // Position décalée à gauche
                        size: { x: 11, y: 1.5, z: 2 },        // Taille du tapis
                        rotation: { x: 0, y: Math.PI / 2, z: 0 } // Orientation verticale
                    },
                    physics: {
                        mass: 0,
                        friction: 0,
                        restitution: 0
                    },
                    appearance: {
                        color: 0x00FF00, // Vert
                        shapeType: 'box',
                        opacity: 1
                    },
                    collider: {
                        type: 'box',
                        size: { x: 11, y: 1.5, z: 2 }
                    },
                    speed: 1,
                });
            }

            animate() {
                requestAnimationFrame(this.animate);

                // Mettre à jour la physique
                this.physicsManager.step();

                // Mettre à jour tous les objets dynamiques
                this.dynamicObjects.forEach(obj => obj.update());

                // Mettre à jour le joueur
                this.player.update();

                // Rendu de la scène avec la caméra du joueur
                this.sceneManager.render(this.player.camera);
            }

            start() {
                this.animate();
            }

            onWindowResize() {
                this.player.camera.aspect = window.innerWidth / window.innerHeight;
                this.player.camera.updateProjectionMatrix();
                this.sceneManager.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Initialisation du jeu
        const game = new Game();
        game.start();
    </script>
</body>

</html>